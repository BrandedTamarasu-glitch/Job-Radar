---
phase: 26-interactive-quick-edit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - job_radar/profile_editor.py
autonomous: true

must_haves:
  truths:
    - "User can select a field to edit from a categorized menu showing current values"
    - "List fields (skills, titles, dealbreakers) offer add/remove/replace submenu"
    - "Boolean fields (new_only) present explicit Yes/No choice"
    - "Text and number fields pre-fill current value for editing"
    - "User sees before/after diff preview before every save"
    - "User must confirm change before profile is saved; declining prints friendly message"
    - "Invalid input is rejected with clear error and user is re-prompted"
    - "After save or decline, user returns to field menu for multi-field editing"
    - "Explicit Done option exits the editor loop"
  artifacts:
    - path: "job_radar/profile_editor.py"
      provides: "Interactive profile editor module"
      exports: ["run_profile_editor"]
      min_lines: 200
  key_links:
    - from: "job_radar/profile_editor.py"
      to: "job_radar/wizard.py"
      via: "validator imports"
      pattern: "from .wizard import.*Validator.*custom_style"
    - from: "job_radar/profile_editor.py"
      to: "job_radar/profile_manager.py"
      via: "save_profile and load_profile"
      pattern: "from .profile_manager import (save_profile|load_profile)"
    - from: "job_radar/profile_editor.py"
      to: "job_radar/search.py"
      via: "_Colors class for styling"
      pattern: "from .search import _Colors"
    - from: "job_radar/profile_editor.py"
      to: "job_radar/config.py"
      via: "load_config for reading preferences"
      pattern: "from .config import load_config"
---

<objective>
Create the interactive profile editor module (profile_editor.py) with loop-based field selection, field-type dispatching, list add/remove submenu, diff preview with confirmation, and wizard validator reuse.

Purpose: This is the core editing experience for Phase 26 -- users can update any profile field through a guided interactive flow that shows changes before saving, with validation that matches the setup wizard.

Output: job_radar/profile_editor.py with run_profile_editor() as the public API.
</objective>

<execution_context>
@/home/corye/.claude/get-shit-done/workflows/execute-plan.md
@/home/corye/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-interactive-quick-edit/26-CONTEXT.md
@.planning/phases/26-interactive-quick-edit/26-RESEARCH.md
@job_radar/wizard.py
@job_radar/profile_manager.py
@job_radar/profile_display.py
@job_radar/search.py
@job_radar/config.py
@job_radar/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create profile_editor.py with field menu, editing, diff, and confirmation</name>
  <files>job_radar/profile_editor.py</files>
  <action>
Create `job_radar/profile_editor.py` with the following structure:

**Imports:**
- `from .wizard import NonEmptyValidator, CommaSeparatedValidator, ScoreValidator, YearsExperienceValidator, CompensationValidator, custom_style` (reuse ALL validators, do NOT duplicate)
- `from .profile_manager import save_profile, load_profile, _write_json_atomic, ProfileValidationError`
- `from .config import load_config`
- `from .search import _Colors as C`
- `import questionary` and `from questionary import Separator, Choice`
- `from pathlib import Path`

**Constants:**
Define field metadata mapping field keys to their display names, types, and which file they belong to:
```python
# Fields stored in profile.json
PROFILE_FIELDS = {
    "name": {"display": "Name", "type": "text", "category": "IDENTITY"},
    "years_experience": {"display": "Experience", "type": "number", "category": "IDENTITY"},
    "location": {"display": "Location", "type": "text", "category": "IDENTITY", "optional": True},
    "core_skills": {"display": "Core Skills", "type": "list", "category": "SKILLS"},
    "target_titles": {"display": "Target Titles", "type": "list", "category": "SKILLS"},
    "dealbreakers": {"display": "Dealbreakers", "type": "list", "category": "FILTERS", "optional": True},
}
# Fields stored in config.json
CONFIG_FIELDS = {
    "min_score": {"display": "Min Score", "type": "number", "category": "PREFERENCES"},
    "new_only": {"display": "New Jobs Only", "type": "boolean", "category": "PREFERENCES"},
}
```

Map field keys to their validators (reuse wizard validators):
```python
FIELD_VALIDATORS = {
    "name": NonEmptyValidator(),
    "years_experience": YearsExperienceValidator(),
    "core_skills": CommaSeparatedValidator(min_items=1, field_name="skill"),
    "target_titles": CommaSeparatedValidator(min_items=1, field_name="title"),
    "min_score": ScoreValidator(),
}
```

**Public API -- `run_profile_editor(profile_path: Path, config_path: Path) -> bool`:**
Main editor loop. Returns True if any changes were saved during the session.

```
while True:
    1. Reload profile via load_profile(profile_path) and config via load_config()
       (reload each iteration so menu shows latest values after edits)
    2. Build categorized field menu via _build_field_choices(profile, config)
    3. Present questionary.select() menu with custom_style
    4. If result is None (Ctrl+C) or contains "Done": break
    5. Parse field key from selection string
    6. Call _edit_field(field_key, profile, config, profile_path, config_path)
    7. If _edit_field returns True: set any_changes = True
    8. Loop continues (return to menu)
return any_changes
```

**`_build_field_choices(profile: dict, config: dict) -> list`:**
Build categorized menu choices showing current values next to field names.

- Group fields by category using Separator headers: "--- IDENTITY ---", "--- SKILLS ---", "--- FILTERS ---", "--- PREFERENCES ---"
- For each field, format as: `questionary.Choice(title="Display Name (current_value)", value=field_key)`
  - Text fields: show value or "(not set)"
  - List fields: show item count, e.g., "Core Skills (5 items)"
  - Number fields: show value
  - Boolean fields: show "Yes" or "No"
  - Experience: show "X years"
- Add final separator then "Done -- exit editor" choice with value "done"

IMPORTANT: Use questionary.Choice objects with `value` parameter so we get the field key back directly, not a display string we have to parse. Example:
```python
Choice(title=f"Name ({profile.get('name', '(not set)')})", value="name")
```

**`_edit_field(field_key: str, profile: dict, config: dict, profile_path: Path, config_path: Path) -> bool`:**
Dispatch to appropriate editor based on field type. Returns True if saved.

```python
if field_key in CONFIG_FIELDS:
    field_meta = CONFIG_FIELDS[field_key]
else:
    field_meta = PROFILE_FIELDS[field_key]

field_type = field_meta["type"]

if field_type == "list":
    return _edit_list_field(field_key, profile, profile_path)
elif field_type == "boolean":
    return _edit_boolean_field(field_key, config, config_path)
elif field_type == "number":
    # min_score is in config, years_experience is in profile
    if field_key in CONFIG_FIELDS:
        return _edit_number_field(field_key, config, config_path, is_config=True)
    else:
        return _edit_number_field(field_key, profile, profile_path, is_config=False)
else:  # text
    return _edit_text_field(field_key, profile, profile_path)
```

**`_edit_text_field(field_key: str, data: dict, save_path: Path) -> bool`:**
Edit simple text field (name, location).
- Get current value: `data.get(field_key, "")`
- Prompt with `questionary.text()`, `default=str(current)`, validator from FIELD_VALIDATORS.get(field_key) (may be None for optional fields like location)
- If result is None: return False (cancelled)
- For optional fields: if new value is empty string, treat as clearing the field
- Call `_show_diff_and_confirm(field_key, current, new_value)`
- If confirmed: update data dict, call `save_profile(data, save_path)`, return True
- If declined: return False

**`_edit_number_field(field_key: str, data: dict, save_path: Path, is_config: bool) -> bool`:**
Edit numeric field (years_experience, min_score).
- Get current value from data
- Prompt with `questionary.text()`, default=str(current), validator from FIELD_VALIDATORS
- If result is None: return False
- Parse: int for years_experience, float for min_score
- Call `_show_diff_and_confirm()`
- If confirmed:
  - For years_experience: also recalculate level (same logic as wizard: <2=junior, <5=mid, <10=senior, else principal)
  - Update data dict
  - If is_config: `_write_json_atomic(save_path, data)` (config uses atomic write but no backup/validation)
  - Else: `save_profile(data, save_path)` (profile uses full backup+validate pipeline)
  - Return True
- If declined: return False

**`_edit_boolean_field(field_key: str, config: dict, config_path: Path) -> bool`:**
Edit boolean field (new_only) with explicit Yes/No choice (per user decision -- no auto-toggle).
- Get current value: `config.get(field_key, True)`
- Use `questionary.confirm()` with `default=current_value`, style=custom_style
- If result is None: return False
- If result == current value: print "No change." and return False
- Call `_show_diff_and_confirm(field_key, "Yes" if current else "No", "Yes" if new_val else "No")`
- If confirmed: update config, `_write_json_atomic(config_path, config)`, return True
- If declined: return False

**`_edit_list_field(field_key: str, profile: dict, profile_path: Path) -> bool`:**
Edit list field via add/remove/replace submenu (per user decision for surgical edits on long lists).
- Get current items: `profile.get(field_key, [])`
- Present submenu via questionary.select():
  - "Add items"
  - "Remove items"
  - "Replace all"
  - "Back to field menu"
- If None or "Back": return False

- **Add items:**
  - Prompt comma-separated input with CommaSeparatedValidator
  - Parse into list, append to current_items
  - Show diff and confirm (show full old list vs full new list)
  - If confirmed: update profile, save_profile(), return True

- **Remove items:**
  - If current_items is empty: print "No items to remove", return False
  - Use questionary.checkbox() with Choice objects for each current item
  - If nothing selected: return False
  - Compute updated list (items not in to_remove)
  - Show diff and confirm
  - If confirmed: update profile, save_profile(), return True

- **Replace all:**
  - Prompt with current value pre-filled as comma-separated string
  - Use appropriate validator from FIELD_VALIDATORS
  - Parse into list
  - Show diff and confirm
  - If confirmed: update profile, save_profile(), return True

**`_show_diff_and_confirm(field_name: str, old_value, new_value) -> bool`:**
Display side-by-side diff and ask for confirmation. Respects NO_COLOR via _Colors.
- Format values using `_format_value_for_diff()`
- Get display name from PROFILE_FIELDS or CONFIG_FIELDS
- Print:
  ```
  \n{display_name}:
    Old: {old_display}
    New: {BOLD}{new_display}{RESET}
  ```
- Use `questionary.confirm("Apply this change?", default=False, style=custom_style)`
  - default=False per user decision (safety: default No)
- If not confirmed: print "Change discarded -- profile unchanged." (per user decision)
- Return confirmed boolean

**`_format_value_for_diff(value) -> str`:**
Format any value type for diff display.
- list: ", ".join(value) if value else "(empty)"
- bool: "Yes" if value else "No"
- None or "": "(not set)"
- int/float: str(value)
- str: value

**Error handling:**
- Wrap save_profile() calls in try/except ProfileValidationError -- on error, print the error message in red and return False (user gets re-prompted on next loop iteration)
- questionary returning None (Ctrl+C) always means "go back" / "cancel", never crash

**Style notes:**
- Use `C.BOLD`, `C.RESET`, `C.GREEN`, `C.RED` from _Colors (respects NO_COLOR automatically)
- Use `custom_style` from wizard.py for all questionary prompts (consistent look)
- Follow existing code patterns from wizard.py for questionary usage

IMPORTANT per user decisions:
- "Apply this change? (y/N)" with default=False
- "Change discarded -- profile unchanged." on decline
- After save: return to field menu (loop continues)
- After decline: return to field menu (loop continues)
- "Done -- exit editor" as last menu item
  </action>
  <verify>
Run: `python -c "from job_radar.profile_editor import run_profile_editor; print('import OK')"` -- should print "import OK" with no errors.

Run: `python -c "from job_radar.profile_editor import _build_field_choices, _format_value_for_diff, _show_diff_and_confirm; print('helpers OK')"` -- should print "helpers OK".

Verify validators are imported (not duplicated): `grep -c "class.*Validator" job_radar/profile_editor.py` should return 0 (no validator classes defined in editor).
  </verify>
  <done>
profile_editor.py exists with run_profile_editor() as public API. All validators imported from wizard.py (zero duplication). Field menu uses Separator categories and Choice objects with current values. List fields use add/remove/replace submenu. Diff preview shows "Old: X / New: (bold)Y" with "Apply this change? (y/N)" confirmation (default No). Editor loop returns to menu after save or decline. "Done -- exit editor" exits cleanly.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from job_radar.profile_editor import run_profile_editor"` -- imports without error
2. `grep -c "class.*Validator" job_radar/profile_editor.py` -- returns 0 (validators not duplicated)
3. `grep "from .wizard import" job_radar/profile_editor.py` -- shows validator imports
4. `grep "from .profile_manager import" job_radar/profile_editor.py` -- shows save_profile, load_profile imports
5. `grep "default=False" job_radar/profile_editor.py` -- confirm prompt defaults to No
6. `grep "Change discarded" job_radar/profile_editor.py` -- friendly cancel message present
7. `grep "Done" job_radar/profile_editor.py` -- exit editor option present
</verification>

<success_criteria>
- profile_editor.py is a complete, importable module
- run_profile_editor() implements the full editor loop with all field types
- All wizard validators reused via import, zero duplication
- Diff preview and confirmation flow matches user decisions exactly
- List fields support add/remove/replace operations
- Boolean fields use explicit Yes/No choice
- Text and number fields pre-fill current values
- Error handling catches ProfileValidationError and displays friendly messages
</success_criteria>

<output>
After completion, create `.planning/phases/26-interactive-quick-edit/26-01-SUMMARY.md`
</output>
