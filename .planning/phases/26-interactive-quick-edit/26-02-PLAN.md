---
phase: 26-interactive-quick-edit
plan: 02
type: execute
wave: 2
depends_on: ["26-01"]
files_modified:
  - job_radar/search.py
  - tests/test_profile_editor.py
autonomous: true

must_haves:
  truths:
    - "Running job-radar --edit-profile launches the interactive editor"
    - "The --view-profile 'Want to edit?' prompt now launches the real editor instead of placeholder"
    - "After editing via --edit-profile, user is offered 'Profile updated. Run search now? (y/N)'"
    - "After editing via --view-profile, user is offered 'Profile updated. Run search now? (y/N)'"
    - "Tests verify editor module functions and CLI integration points"
  artifacts:
    - path: "job_radar/search.py"
      provides: "--edit-profile flag and wired editor calls"
      contains: "edit.profile"
    - path: "tests/test_profile_editor.py"
      provides: "Tests for profile editor module"
      min_lines: 100
  key_links:
    - from: "job_radar/search.py"
      to: "job_radar/profile_editor.py"
      via: "import and call run_profile_editor"
      pattern: "from .profile_editor import run_profile_editor"
    - from: "job_radar/search.py"
      to: "job_radar/search.py"
      via: "--edit-profile argparse flag"
      pattern: "edit.profile"
---

<objective>
Wire profile_editor.py into the CLI by adding the --edit-profile flag, replacing the --view-profile placeholder, offering search after edit, and creating comprehensive tests.

Purpose: Connects the editor module to both CLI entry points (--edit-profile and --view-profile edit prompt) and ensures the complete flow works with tests.

Output: Modified search.py with --edit-profile flag, replaced placeholder, and new test_profile_editor.py.
</objective>

<execution_context>
@/home/corye/.claude/get-shit-done/workflows/execute-plan.md
@/home/corye/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-interactive-quick-edit/26-CONTEXT.md
@.planning/phases/26-interactive-quick-edit/26-RESEARCH.md
@.planning/phases/26-interactive-quick-edit/26-01-SUMMARY.md
@job_radar/profile_editor.py
@job_radar/search.py
@job_radar/wizard.py
@job_radar/profile_manager.py
@job_radar/config.py
@job_radar/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add --edit-profile flag and wire editor into search.py</name>
  <files>job_radar/search.py</files>
  <action>
Modify `job_radar/search.py` with three changes:

**Change 1: Add --edit-profile flag to parse_args()**

In the Profile Options argument group (after --view-profile), add:
```python
profile_group.add_argument(
    "--edit-profile",
    action="store_true",
    help="Edit profile fields interactively with diff preview",
)
```

Update the help text in `description` to mention --edit-profile alongside --view-profile:
```
RETURNING? Run without flags to search with your saved profile.
Use --view-profile to review your settings before searching.
Use --edit-profile to update individual profile fields.
Or use the flags below to customize your search:
```

Update the epilog Profile Management section:
```
Profile Management:
  --view-profile                       Show profile and offer to edit
  --edit-profile                       Edit profile fields interactively
  --no-wizard                          Suppress wizard and profile preview
  (coming soon: --update-skills, --set-min-score)
```

**Change 2: Add --edit-profile early exit handler in main()**

Add a new early exit handler in main() AFTER the --view-profile block (and BEFORE the profile_path_str resolution). The handler should:

```python
if args.edit_profile:
    from .profile_editor import run_profile_editor
    from pathlib import Path as _Path

    # Resolve profile path (same logic as main flow)
    ep_path_str = args.profile
    if not ep_path_str:
        from .paths import get_data_dir
        ep_path_str = str(get_data_dir() / "profile.json")

    ep_path = _Path(ep_path_str).expanduser()

    # If no profile exists, launch wizard first
    if not ep_path.exists():
        print(f"\n{C.YELLOW}No profile found -- launching setup wizard...{C.RESET}\n")
        from .wizard import run_setup_wizard
        if not run_setup_wizard():
            print("\nSetup cancelled.")
            sys.exit(1)

    # Resolve config path
    config_path_str = args.config
    if not config_path_str:
        from .paths import get_data_dir
        data_dir = get_data_dir()
        config_path_str = str(data_dir / "config.json")
    config_path = _Path(config_path_str).expanduser()

    changed = run_profile_editor(ep_path, config_path)

    # Per user decision: offer to run search after editing
    if changed:
        try:
            run_search = questionary.confirm(
                "Profile updated. Run search now?",
                default=False,
                style=custom_style
            ).ask()
            if run_search:
                # Fall through to main search flow by NOT exiting
                pass
            else:
                sys.exit(0)
        except (EOFError, KeyboardInterrupt):
            sys.exit(0)
    else:
        sys.exit(0)
```

Note: This requires importing questionary and custom_style at the top of the handler block:
```python
import questionary
from .wizard import custom_style
```

Actually, to keep imports light, do the questionary import inside the if-block (lazy import pattern, consistent with how search.py does other imports).

**Change 3: Replace --view-profile placeholder with real editor call**

In the existing --view-profile handler (lines ~479-486), replace the placeholder:
```python
# OLD (placeholder):
try:
    edit = input("\nWant to edit? (y/N) ").strip().lower()
    if edit == 'y':
        print(f"\n{C.YELLOW}Interactive editing coming in a future update.{C.RESET}")
except (EOFError, KeyboardInterrupt):
    pass

sys.exit(0)
```

With the real editor integration:
```python
# NEW (real editor):
try:
    edit = input("\nWant to edit? (y/N) ").strip().lower()
    if edit == 'y':
        from .profile_editor import run_profile_editor
        from pathlib import Path as _Path

        # Resolve config path
        config_path_str = args.config
        if not config_path_str:
            from .paths import get_data_dir
            config_path_str = str(get_data_dir() / "config.json")
        config_path = _Path(config_path_str).expanduser()

        changed = run_profile_editor(vp_path, config_path)

        if changed:
            import questionary
            from .wizard import custom_style
            try:
                run_search = questionary.confirm(
                    "Profile updated. Run search now?",
                    default=False,
                    style=custom_style
                ).ask()
                if run_search:
                    # Reload profile and fall through to search
                    # For now, just tell user to re-run (simpler than refactoring main flow)
                    print(f"\n{C.GREEN}Run 'job-radar' to search with your updated profile.{C.RESET}")
                    sys.exit(0)
            except (EOFError, KeyboardInterrupt):
                pass
except (EOFError, KeyboardInterrupt):
    pass

sys.exit(0)
```

Note: For --view-profile path, the search offer just prints a helpful message and exits. The --edit-profile path can fall through to main search flow since it's positioned earlier in main(). This avoids complex refactoring of the main() function to support "restart search from middle."
  </action>
  <verify>
Run: `python -m job_radar.search --help` and verify --edit-profile appears in the help output.

Run: `grep "edit.profile" job_radar/search.py` to confirm the flag and handler exist.

Run: `grep -c "coming in a future update" job_radar/search.py` -- should return 0 (placeholder removed).
  </verify>
  <done>
--edit-profile flag added to CLI. --view-profile placeholder replaced with real editor call. Both paths offer "Run search now?" after editing. Help text updated to document --edit-profile.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create tests for profile_editor module and CLI integration</name>
  <files>tests/test_profile_editor.py</files>
  <action>
Create `tests/test_profile_editor.py` with tests covering the editor module functions and CLI integration.

**Test fixtures:**
```python
import json
import pytest
from pathlib import Path
from unittest.mock import patch, MagicMock

# Fixture: create a valid profile file and config file in tmp_path
@pytest.fixture
def profile_and_config(tmp_path):
    """Create valid profile.json and config.json in tmp_path."""
    profile_path = tmp_path / "profile.json"
    config_path = tmp_path / "config.json"
    backup_dir = tmp_path / "backups"
    backup_dir.mkdir()

    profile_data = {
        "name": "Test User",
        "years_experience": 5,
        "level": "mid",
        "target_titles": ["Software Engineer", "Backend Developer"],
        "core_skills": ["Python", "JavaScript", "React"],
        "location": "Remote",
        "dealbreakers": ["on-site only"],
        "schema_version": 1,
    }
    config_data = {
        "min_score": 2.8,
        "new_only": True,
        "profile_path": str(profile_path),
    }

    profile_path.write_text(json.dumps(profile_data, indent=2))
    config_path.write_text(json.dumps(config_data, indent=2))

    return profile_path, config_path, backup_dir
```

**Test categories (aim for 15-20 tests total):**

1. **Menu building tests (3-4 tests):**
   - `test_build_field_choices_includes_all_fields`: Call _build_field_choices() with sample profile/config, verify all 8 editable fields appear as Choice objects
   - `test_build_field_choices_shows_current_values`: Verify menu choices contain current values (e.g., "Name" choice has "Test User" in title)
   - `test_build_field_choices_includes_done_option`: Verify last non-separator choice has value "done"
   - `test_build_field_choices_has_category_separators`: Verify Separator objects exist for IDENTITY, SKILLS, etc.

2. **Value formatting tests (4-5 tests):**
   - `test_format_value_for_diff_list`: list ["a", "b"] formats as "a, b"
   - `test_format_value_for_diff_empty_list`: empty list formats as "(empty)"
   - `test_format_value_for_diff_none`: None formats as "(not set)"
   - `test_format_value_for_diff_number`: 2.8 formats as "2.8"
   - `test_format_value_for_diff_bool`: True formats as "Yes", False formats as "No"

3. **Diff and confirmation tests (3 tests):**
   - `test_show_diff_and_confirm_approved`: Mock questionary.confirm to return True, verify returns True
   - `test_show_diff_and_confirm_declined`: Mock questionary.confirm to return False, verify returns False and prints "Change discarded"
   - `test_show_diff_and_confirm_displays_old_new`: Capture stdout, verify "Old:" and "New:" appear in output

4. **Editor integration tests (3-4 tests, mock questionary):**
   - `test_edit_text_field_saves_on_confirm`: Mock questionary.text and questionary.confirm, verify profile file updated
   - `test_edit_text_field_discards_on_decline`: Mock confirm to return False, verify profile file unchanged
   - `test_edit_list_field_add_items`: Mock submenu to "Add items", text input, confirm. Verify items added to profile
   - `test_edit_boolean_field_saves_config`: Mock confirm choices, verify config.json updated

5. **Validator reuse test (1 test):**
   - `test_validators_imported_not_duplicated`: Import profile_editor, verify it has no Validator class definitions (only imports from wizard)

6. **CLI flag test (1-2 tests):**
   - `test_edit_profile_flag_exists`: Call parse_args with --edit-profile, verify args.edit_profile is True
   - `test_help_text_includes_edit_profile`: Capture help output, verify --edit-profile mentioned

**Important mocking notes:**
- Mock `job_radar.profile_editor.questionary` for interactive prompts
- Mock `job_radar.profile_editor.load_profile` to return profile dict from fixture
- Mock `job_radar.profile_editor.save_profile` to verify it's called with correct args
- Mock `job_radar.paths.get_backup_dir` to return tmp_path / "backups" (prevents writing to real user dirs)
- For CLI tests, use `job_radar.search.parse_args` directly (no need to mock)

**Pattern to follow:** Look at tests/test_profile_display.py and tests/test_wizard.py for existing mock patterns in this codebase.
  </action>
  <verify>
Run: `python -m pytest tests/test_profile_editor.py -v` -- all tests pass.

Run: `python -m pytest tests/ -v --tb=short` -- full test suite passes with zero regressions.
  </verify>
  <done>
test_profile_editor.py exists with 15+ tests covering menu building, value formatting, diff display, field editing, validator reuse, and CLI flag integration. Full test suite passes with zero regressions.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_profile_editor.py -v` -- all tests pass
2. `python -m pytest tests/ -v --tb=short` -- full suite passes, zero regressions
3. `python -m job_radar.search --help | grep edit-profile` -- flag documented
4. `grep -c "coming in a future update" job_radar/search.py` -- returns 0 (placeholder removed)
5. `python -c "from job_radar.profile_editor import run_profile_editor"` -- imports cleanly
</verification>

<success_criteria>
- --edit-profile flag added and documented in help text
- --view-profile placeholder replaced with real editor call
- Both entry points offer "Run search now?" after editing
- 15+ tests pass covering editor functions and CLI integration
- Full test suite passes with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/26-interactive-quick-edit/26-02-SUMMARY.md`
</output>
