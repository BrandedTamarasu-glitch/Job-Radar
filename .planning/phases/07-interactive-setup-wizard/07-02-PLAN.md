---
phase: 07-interactive-setup-wizard
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - tests/test_wizard.py
  - job_radar/__main__.py
autonomous: true

must_haves:
  truths:
    - "Wizard tests verify all required fields are collected and written to JSON"
    - "Wizard tests verify optional fields can be skipped"
    - "Wizard tests verify Ctrl+C cancellation returns False"
    - "Wizard tests verify invalid inputs trigger validation errors"
    - "Wizard tests verify mid-wizard /back navigation returns to previous question"
    - "Wizard tests verify no default values on profile fields, default 2.8 on score"
    - "First run detection triggers wizard before search in __main__.py"
    - "Repeat run (profile exists) skips wizard and goes directly to search"
  artifacts:
    - path: "tests/test_wizard.py"
      provides: "Wizard unit tests with mocked questionary prompts"
      contains: "test_wizard"
    - path: "job_radar/__main__.py"
      provides: "First-run wizard trigger before search"
      contains: "is_first_run"
  key_links:
    - from: "job_radar/__main__.py"
      to: "job_radar/wizard.py"
      via: "is_first_run() check and run_setup_wizard() call"
      pattern: "from job_radar.wizard import"
    - from: "tests/test_wizard.py"
      to: "job_radar/wizard.py"
      via: "pytest-mock patching questionary prompts"
      pattern: "from job_radar.wizard import"
---

<objective>
Write comprehensive wizard tests using pytest-mock to verify all prompt flows, validation, and file output, then wire the wizard into the application entry point with first-run detection.

Purpose: Tests ensure the wizard works correctly without manual interaction (critical for CI), and the entry point integration makes the wizard actually trigger on first launch.

Output: tests/test_wizard.py with full wizard coverage, and updated __main__.py with first-run detection.
</objective>

<execution_context>
@/Users/coryebert/.claude/get-shit-done/workflows/execute-plan.md
@/Users/coryebert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@.planning/phases/07-interactive-setup-wizard/07-CONTEXT.md
@.planning/phases/07-interactive-setup-wizard/07-RESEARCH.md
@.planning/phases/07-interactive-setup-wizard/07-01-SUMMARY.md

@job_radar/wizard.py
@job_radar/__main__.py
@job_radar/paths.py
@tests/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create wizard test suite with mocked questionary prompts</name>
  <files>tests/test_wizard.py</files>
  <action>
Create `tests/test_wizard.py` with comprehensive tests for the wizard module. All tests must mock questionary prompts (no interactive input during CI).

**Test pattern (from RESEARCH.md):**
Mock `questionary.text` and `questionary.confirm` to return Mock objects with `.ask()` returning predetermined values. Mock `questionary.select` for the edit-a-field flow. Mock `job_radar.wizard._write_json_atomic` to avoid filesystem writes in unit tests.

**Required test cases:**

1. `test_wizard_happy_path_all_fields` -- Provide all 7 answers (name, titles, skills, location, dealbreakers, score, new_only) + "Save" on confirmation. Assert:
   - run_setup_wizard() returns True
   - _write_json_atomic called twice (profile.json, config.json)
   - profile.json data has correct name, target_titles as list, core_skills as list, location, dealbreakers as list
   - config.json data has correct min_score (float), new_only (bool)

2. `test_wizard_optional_fields_skipped` -- Provide name, titles, skills, empty location, empty dealbreakers, score, new_only + "Save". Assert:
   - run_setup_wizard() returns True
   - profile.json data does NOT contain "location" or "dealbreakers" keys (or contains them as empty/omitted per wizard implementation)

3. `test_wizard_cancel_at_confirmation` -- Provide all answers but select "Cancel" at save confirmation. Assert:
   - run_setup_wizard() returns False
   - _write_json_atomic never called

4. `test_wizard_ctrl_c_cancellation` -- First prompt returns None (simulates Ctrl+C), then confirm exit. Assert:
   - run_setup_wizard() returns False
   - _write_json_atomic never called

5. `test_validator_non_empty_rejects_blank` -- Create NonEmptyValidator instance, call validate() with empty document. Assert ValidationError raised.

6. `test_validator_non_empty_accepts_text` -- Create NonEmptyValidator instance, call validate() with "hello". Assert no error raised.

7. `test_validator_comma_separated_rejects_empty` -- Create CommaSeparatedValidator, validate empty string. Assert ValidationError.

8. `test_validator_comma_separated_accepts_list` -- Create CommaSeparatedValidator, validate "Python, JavaScript". Assert no error.

9. `test_validator_comma_separated_min_items` -- Create CommaSeparatedValidator(min_items=2), validate "Python" (only 1 item). Assert ValidationError.

10. `test_validator_score_rejects_out_of_range` -- Create ScoreValidator, validate "0.5" and "6.0". Assert ValidationError for both.

11. `test_validator_score_rejects_non_numeric` -- Create ScoreValidator, validate "abc". Assert ValidationError.

12. `test_validator_score_accepts_valid` -- Create ScoreValidator, validate "3.0". Assert no error.

13. `test_is_first_run_no_profile` -- Mock get_data_dir to return tmp_path, no profile.json exists. Assert is_first_run() returns True.

14. `test_is_first_run_profile_exists` -- Mock get_data_dir to return tmp_path, create profile.json in tmp_path. Assert is_first_run() returns False.

15. `test_write_json_atomic_creates_file` -- Use tmp_path, call _write_json_atomic with sample data. Assert file exists with correct JSON content.

16. `test_write_json_atomic_creates_parent_dirs` -- Use tmp_path / "subdir" / "file.json", call _write_json_atomic. Assert file created with parent dirs.

17. `test_wizard_edit_field_flow` -- Provide all answers, select "Edit a field" at confirmation, select "name" field, provide new name, then "Save". Assert final profile.json data has the EDITED name.

18. `test_wizard_back_navigation` -- Provide name, then type "/back" on titles prompt. Assert wizard re-prompts for name (idx goes back to 0). Provide name again, then continue forward through all remaining questions + "Save". Assert final profile.json has correct data.

19. `test_wizard_back_at_first_question` -- Type "/back" on the very first question (name). Assert wizard stays on name (idx doesn't go below 0), re-prompts for name.

20. `test_wizard_no_default_values_on_profile_fields` -- Verify that questionary.text() calls for name, titles, skills, location, and dealbreakers do NOT pass a `default=` argument (or pass no default). Verify that min_score DOES pass `default="2.8"`. This can be checked by inspecting mock call args.

**Validator testing approach:**
Create a minimal mock document object with `.text` attribute for testing validators directly, since questionary validators receive a prompt_toolkit Document:
```python
class MockDocument:
    def __init__(self, text):
        self.text = text
```

**Mocking strategy:**
Use `mocker.patch('job_radar.wizard.questionary')` or patch individual functions like `mocker.patch('job_radar.wizard.questionary.text')`. The exact patch target depends on how wizard.py imports questionary -- match the import style.
  </action>
  <verify>
Run: `cd "/Users/coryebert/Documents/Job Hunt Python/Project Folder/Job-Radar" && python -m pytest tests/test_wizard.py -v` -- all wizard tests pass.

Run: `cd "/Users/coryebert/Documents/Job Hunt Python/Project Folder/Job-Radar" && python -m pytest tests/ -q` -- all tests pass (no regressions in existing tests).
  </verify>
  <done>
tests/test_wizard.py exists with 20+ test cases covering: happy path, optional field skipping, cancellation, Ctrl+C, all three validators, is_first_run detection, atomic file writing, edit-a-field flow, mid-wizard /back navigation, back-at-first-question boundary, and no-default-values verification. All tests pass. No regressions in existing test suite.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire wizard into __main__.py entry point with first-run detection</name>
  <files>job_radar/__main__.py</files>
  <action>
Modify `job_radar/__main__.py` to check for first run and launch wizard before search.

**Insert first-run detection AFTER banner display, BEFORE search_main() call.**

The current main() flow is:
1. _fix_ssl_for_frozen()
2. display_banner()
3. search_main()

New flow:
1. _fix_ssl_for_frozen()
2. display_banner()
3. **First-run check: if is_first_run(), run wizard**
4. search_main()

**Implementation:**

After the banner try/except block and before the search try/except block, add:

```python
    # First-run setup wizard
    try:
        from job_radar.wizard import is_first_run, run_setup_wizard
        if is_first_run():
            print("\nWelcome to Job Radar!")
            print("Let's set up your profile before your first search.\n")
            if not run_setup_wizard():
                # User cancelled wizard
                print("\nSetup cancelled. Run again when you're ready!")
                sys.exit(0)
            print()  # Blank line before search starts
    except ImportError:
        # questionary not installed -- skip wizard (dev mode without extras)
        pass
    except Exception:
        # Wizard failure is non-critical -- user can still use --profile flag
        pass
```

**Key design decisions:**
- ImportError catch: questionary might not be installed in dev environments that didn't `pip install questionary`. The wizard is a nice-to-have, not a blocker.
- Generic Exception catch: If the wizard crashes for any reason, the app still works via --profile flag. Don't let a wizard bug block the entire application.
- The welcome message is outside the wizard module because __main__.py owns the app-level greeting. The wizard module focuses on the interactive prompts.
- sys.exit(0) on cancel: Clean exit, not an error.

**Important: Do NOT modify search.py's --profile requirement yet.** Phase 8 (Entry Point Integration) will handle making --profile optional when wizard has created a profile. For now, after the wizard creates profile.json, the user still needs --profile to point at it. This is expected -- Phase 8 connects the dots.
  </action>
  <verify>
Run: `cd "/Users/coryebert/Documents/Job Hunt Python/Project Folder/Job-Radar" && python -c "from job_radar.__main__ import main; print('Import OK')"` -- must print "Import OK".

Run: `cd "/Users/coryebert/Documents/Job Hunt Python/Project Folder/Job-Radar" && python -m pytest tests/ -q` -- all tests pass.

Manual review: __main__.py contains is_first_run() check, run_setup_wizard() call, ImportError fallback, and sys.exit(0) on cancel.
  </verify>
  <done>
__main__.py updated with first-run detection that launches wizard before search. ImportError gracefully handled for environments without questionary. Wizard cancellation exits cleanly. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_wizard.py -v` -- all 20+ wizard tests pass
2. `python -m pytest tests/ -q` -- full test suite passes with no regressions
3. `python -c "from job_radar.__main__ import main"` -- imports without error
4. __main__.py contains first-run detection with is_first_run() and run_setup_wizard()
5. __main__.py handles ImportError (no questionary) and Exception (wizard crash) gracefully
</verification>

<success_criteria>
- 20+ wizard tests covering happy path, validation, cancellation, Ctrl+C, edit flow, atomic writes, first-run detection, /back navigation, no-default-values
- All wizard tests pass
- All existing tests pass (no regressions)
- __main__.py triggers wizard on first run (no profile.json)
- __main__.py skips wizard on repeat run (profile.json exists)
- Wizard failure is non-critical (app still works via --profile)
</success_criteria>

<output>
After completion, create `.planning/phases/07-interactive-setup-wizard/07-02-SUMMARY.md`
</output>
