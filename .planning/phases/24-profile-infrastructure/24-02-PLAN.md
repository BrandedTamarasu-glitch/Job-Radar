---
phase: 24-profile-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["24-01"]
files_modified:
  - job_radar/wizard.py
  - job_radar/search.py
  - tests/test_profile_manager.py
autonomous: true

must_haves:
  truths:
    - "All profile I/O in the codebase routes through profile_manager.py"
    - "Wizard saves use profile_manager.save_profile() with atomic writes and automatic backups"
    - "search.py loads profiles via profile_manager.load_profile() with validation and schema migration"
    - "Existing wizard and search functionality is preserved (no user-facing behavior changes)"
    - "Profile manager operations are covered by unit tests"
  artifacts:
    - path: "job_radar/wizard.py"
      provides: "Wizard using profile_manager.save_profile() instead of _write_json_atomic()"
      contains: "from .profile_manager import save_profile"
    - path: "job_radar/search.py"
      provides: "Search using profile_manager.load_profile() and validate_profile()"
      contains: "from .profile_manager import"
    - path: "tests/test_profile_manager.py"
      provides: "Unit tests for atomic write, backup, rotation, validation, schema migration"
      min_lines: 100
  key_links:
    - from: "job_radar/wizard.py"
      to: "job_radar/profile_manager.py"
      via: "save_profile() call replaces _write_json_atomic()"
      pattern: "save_profile\\("
    - from: "job_radar/search.py"
      to: "job_radar/profile_manager.py"
      via: "load_profile and validate_profile imports"
      pattern: "from \\.profile_manager import"
    - from: "tests/test_profile_manager.py"
      to: "job_radar/profile_manager.py"
      via: "tests import and exercise all public functions"
      pattern: "from job_radar\\.profile_manager import"
---

<objective>
Wire wizard.py and search.py to use profile_manager.py for all profile I/O, then create comprehensive unit tests proving atomic writes, backups, rotation, validation, and schema migration work correctly.

Purpose: Completes the centralization requirement (SAFE-05, SAFE-06, SAFE-08) and provides regression protection for all data safety guarantees.

Output: Modified `job_radar/wizard.py`, modified `job_radar/search.py`, new `tests/test_profile_manager.py`.
</objective>

<execution_context>
@/home/corye/.claude/get-shit-done/workflows/execute-plan.md
@/home/corye/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-profile-infrastructure/24-RESEARCH.md
@.planning/phases/24-profile-infrastructure/24-01-SUMMARY.md
@job_radar/profile_manager.py
@job_radar/wizard.py
@job_radar/search.py
@tests/conftest.py
@tests/test_wizard.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire wizard.py and search.py to use profile_manager</name>
  <files>job_radar/wizard.py, job_radar/search.py</files>
  <action>
**wizard.py changes:**

1. Add import at top: `from .profile_manager import save_profile`
2. Remove the entire `_write_json_atomic()` function (lines 145-185). This function is now in profile_manager.py.
3. In `run_setup_wizard()`, find the section near the end where files are written (around line 791-796):
   - Replace `_write_json_atomic(profile_path, profile_data)` with `save_profile(profile_data, profile_path)`
   - Keep the `_write_json_atomic(config_path, config_data)` call BUT since config.json is not a profile, instead inline the atomic write pattern for config only. Actually, the simplest approach: keep a minimal `_write_json_atomic()` private function for config.json writes only (config is not a profile and should NOT go through profile_manager). Rename it to `_write_config_atomic()` to make the distinction clear. Copy the same temp+fsync+rename body.
   - So the final write section becomes:
     ```python
     save_profile(profile_data, profile_path)
     _write_config_atomic(config_path, config_data)
     ```
4. Do NOT change any wizard question flow, validation, or user interaction. Only the file-write path changes.

**search.py changes:**

1. Add import at top (in the relative imports section): `from .profile_manager import load_profile as _pm_load_profile, validate_profile as _pm_validate, ProfileValidationError, ProfileNotFoundError`
2. Rewrite `load_profile(path: str) -> dict` to delegate to profile_manager:
   - Convert `path` string to `Path` object
   - Try `return _pm_load_profile(Path(path))`
   - Catch `ProfileNotFoundError`: print existing user-friendly error message with color codes and `sys.exit(1)` (preserve current UX)
   - Catch `ProfileValidationError`: print error message with color codes and `sys.exit(1)` (preserve current UX)
   - Keep the "Warn about recommended fields" section (lines 279-293) AFTER successful load -- this is a UX feature not a validation concern. Call it after load succeeds.
   - The function signature stays the same (`path: str`) for backward compatibility with callers.
3. Rewrite `load_profile_with_recovery(path: str, _retry: int = 0) -> dict` to use profile_manager:
   - Keep the same retry logic and wizard recovery flow
   - Replace the inline JSON loading + field checking with a try/except around `_pm_load_profile(Path(expanded_path))`:
     - Catch `ProfileNotFoundError`: trigger wizard recovery (same as current "File missing" path)
     - Catch `ProfileValidationError` with `"Invalid JSON"` in message: backup corrupt file, trigger wizard recovery (same as current "JSON decode error" path)
     - Catch other `ProfileValidationError`: backup invalid file, trigger wizard recovery (same as current "Missing required fields" / "Invalid field types" paths)
   - This consolidates the 4 separate check blocks into one try/except with the same user-facing behavior
4. Remove the duplicate validation logic that was inline in both functions (the required field checks, isinstance checks). That logic now lives in profile_manager.validate_profile().
5. Keep the `--validate-profile` handler in `main()` working -- it calls `load_profile()` which now delegates to profile_manager.

**Critical: preserve all user-facing behavior.** The colored error messages, the recommended field warnings, the wizard recovery flow -- all must produce identical output to the user. Only the internal code path changes.
  </action>
  <verify>
Run existing tests to ensure no regressions:
`cd /home/corye/Claude/Job-Radar && python -m pytest tests/test_wizard.py -v --tb=short 2>&1 | tail -20`

Run: `cd /home/corye/Claude/Job-Radar && python -c "from job_radar.search import load_profile; print('search.load_profile import OK')"`

Run: `cd /home/corye/Claude/Job-Radar && python -c "from job_radar.wizard import run_setup_wizard; print('wizard import OK')"`

Verify wizard no longer has standalone _write_json_atomic:
`cd /home/corye/Claude/Job-Radar && python -c "from job_radar import wizard; assert not hasattr(wizard, '_write_json_atomic'), 'Should be removed'; print('_write_json_atomic removed from wizard OK')"` -- Note: if renamed to _write_config_atomic, verify that name exists instead.
  </verify>
  <done>
wizard.py uses save_profile() from profile_manager for profile writes. search.py delegates load_profile() and load_profile_with_recovery() to profile_manager. No duplicate validation logic remains in wizard.py or search.py. Existing tests pass. User-facing behavior (error messages, colors, wizard recovery) unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive unit tests for profile_manager</name>
  <files>tests/test_profile_manager.py</files>
  <action>
Create `tests/test_profile_manager.py` with pytest. Follow existing test conventions: parametrize with descriptive IDs, `tmp_path` fixture for file I/O isolation, section comment headers with dashed lines.

**Test sections:**

1. **Validation tests** (parametrized):
   - `test_validate_rejects_non_dict` -- passes a list, expects `InvalidTypeError`
   - `test_validate_rejects_missing_required_fields` -- parametrize: empty dict (all 3 missing), dict with only name (2 missing). Expect `MissingFieldError`.
   - `test_validate_rejects_empty_target_titles` -- `{"name": "X", "target_titles": [], "core_skills": ["Py"]}` -> `InvalidTypeError`
   - `test_validate_rejects_empty_core_skills` -- `{"name": "X", "target_titles": ["Dev"], "core_skills": []}` -> `InvalidTypeError`
   - `test_validate_rejects_empty_name` -- `{"name": "", "target_titles": ["Dev"], "core_skills": ["Py"]}` -> `InvalidTypeError`
   - `test_validate_rejects_years_out_of_range` -- parametrize: -1, 51. Expect `ProfileValidationError`.
   - `test_validate_rejects_years_wrong_type` -- `years_experience: "five"` -> `InvalidTypeError`
   - `test_validate_rejects_comp_floor_out_of_range` -- parametrize: -1, 1_000_001. Expect `ProfileValidationError`.
   - `test_validate_accepts_valid_profile` -- minimal valid profile (name, target_titles, core_skills). No exception raised.
   - `test_validate_accepts_full_profile` -- profile with all optional fields at valid values. No exception raised.

2. **Save tests** (use `tmp_path`):
   - `test_save_creates_file` -- save valid profile to `tmp_path / "profile.json"`, assert file exists, assert JSON content matches, assert `schema_version == 1`.
   - `test_save_atomic_no_corruption` -- save profile, verify file is valid JSON (simulates that write completed correctly).
   - `test_save_always_sets_schema_version` -- save profile without schema_version key, load back, assert schema_version == 1.
   - `test_save_rejects_invalid_profile` -- save profile missing required fields, expect `ProfileValidationError`, assert NO file created.
   - `test_save_cleans_up_temp_on_validation_error` -- save invalid profile, glob `tmp_path` for `.tmp` files, assert none exist.

3. **Backup tests** (use `tmp_path`):
   - `test_save_creates_backup_on_overwrite` -- save profile twice (need to patch `get_backup_dir` to return `tmp_path / "backups"`). After second save, assert backup directory contains 1 backup file matching `profile_*.json` pattern.
   - `test_backup_preserves_original_content` -- save profile A, save profile B (overwriting). Read backup file, assert it contains profile A data.
   - `test_backup_has_timestamp_in_filename` -- save twice, check backup filename matches `profile_\d{8}_\d{6}_\d{6}\.json` regex.
   - `test_no_backup_on_first_save` -- save to new path (file does not exist yet). Assert backup directory is empty or does not exist.

4. **Backup rotation tests** (use `tmp_path`):
   - `test_rotate_keeps_max_backups` -- create 12 fake backup files in `tmp_path / "backups"` with staggered mtimes (use `os.utime()`). Call `_rotate_backups(backup_dir, max_backups=10)`. Assert exactly 10 files remain, and the 2 oldest are deleted.
   - `test_rotate_no_op_under_limit` -- create 5 backup files, call `_rotate_backups(max_backups=10)`, assert all 5 still exist.

5. **Load tests** (use `tmp_path`):
   - `test_load_valid_profile` -- write valid JSON to file, load it, assert dict matches.
   - `test_load_nonexistent_raises` -- load from path that does not exist, expect `ProfileNotFoundError`.
   - `test_load_invalid_json_raises` -- write `"{not json"` to file, load, expect `ProfileValidationError` with "Invalid JSON" in message.
   - `test_load_invalid_profile_raises` -- write JSON with missing fields, load, expect `MissingFieldError`.

6. **Schema migration tests** (use `tmp_path`):
   - `test_load_migrates_v0_to_v1` -- write valid profile JSON without `schema_version` key. Load it. Assert returned dict has `schema_version == 1`. Read file from disk again and assert `schema_version == 1` was persisted (auto-save).
   - `test_load_accepts_v1` -- write profile with `schema_version: 1`. Load it. Assert no error, schema_version still 1.
   - `test_load_rejects_future_version` -- write profile with `schema_version: 99`. Load it. Expect `ProfileValidationError` with "newer than supported" in message.

**Patching strategy:** For tests that call `save_profile` or `load_profile`, patch `job_radar.profile_manager.get_backup_dir` and `job_radar.profile_manager.get_data_dir` to return `tmp_path`-based directories. Use `unittest.mock.patch` (same pattern as existing tests in `test_tracker.py`). For `_rotate_backups`, import it directly and call with `tmp_path` -- no patching needed.

**Important:** Import `_rotate_backups` for direct testing: `from job_radar.profile_manager import _rotate_backups`
  </action>
  <verify>
Run all profile manager tests:
`cd /home/corye/Claude/Job-Radar && python -m pytest tests/test_profile_manager.py -v --tb=short`

Run the full test suite to verify no regressions:
`cd /home/corye/Claude/Job-Radar && python -m pytest tests/ -v --tb=short 2>&1 | tail -30`
  </verify>
  <done>
test_profile_manager.py contains tests across 6 sections: validation (10+ cases), save (5 cases), backup (4 cases), backup rotation (2 cases), load (4 cases), schema migration (3 cases). All tests pass. Full test suite passes with no regressions.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/test_profile_manager.py -v` -- all tests pass
- `python -m pytest tests/ -v` -- full suite passes (no regressions in wizard, search, etc.)
- `grep -r "_write_json_atomic" job_radar/wizard.py` returns no results (function removed or renamed)
- `grep -r "from .profile_manager import" job_radar/wizard.py job_radar/search.py` confirms both files import from profile_manager
- No duplicate validation logic remains in search.py (no inline `isinstance(profile.get("target_titles"), list)` checks in load_profile)
</verification>

<success_criteria>
1. wizard.py calls save_profile() from profile_manager for profile writes (not _write_json_atomic)
2. search.py load_profile() delegates to profile_manager.load_profile() with colored error handling preserved
3. search.py load_profile_with_recovery() uses profile_manager with same wizard recovery UX
4. test_profile_manager.py has 28+ test cases covering all 6 areas
5. Full test suite passes with zero regressions
6. No profile I/O logic remains outside profile_manager.py (centralization complete)
</success_criteria>

<output>
After completion, create `.planning/phases/24-profile-infrastructure/24-02-SUMMARY.md`
</output>
