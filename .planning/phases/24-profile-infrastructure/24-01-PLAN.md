---
phase: 24-profile-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - job_radar/profile_manager.py
  - job_radar/paths.py
autonomous: true

must_haves:
  truths:
    - "Profile saves never produce corrupted JSON (atomic temp-file-plus-rename)"
    - "Timestamped backup created before every update, old backups beyond 10 deleted"
    - "Profile JSON includes schema_version=1 on every save"
    - "Invalid data rejected with clear error before file write"
    - "Unknown fields preserved silently on save (forward-compatible)"
  artifacts:
    - path: "job_radar/profile_manager.py"
      provides: "Centralized profile I/O with atomic writes, backups, validation, schema versioning"
      exports: ["load_profile", "save_profile", "validate_profile", "ProfileValidationError", "MissingFieldError", "InvalidTypeError", "ProfileNotFoundError", "ProfileCorruptedError"]
      min_lines: 150
    - path: "job_radar/paths.py"
      provides: "get_backup_dir() helper for backup directory resolution"
      contains: "get_backup_dir"
  key_links:
    - from: "job_radar/profile_manager.py"
      to: "job_radar/paths.py"
      via: "import get_backup_dir for backup directory resolution"
      pattern: "from .paths import get_backup_dir"
    - from: "job_radar/profile_manager.py save_profile()"
      to: "job_radar/profile_manager.py validate_profile()"
      via: "validate before write"
      pattern: "validate_profile\\(profile_data\\)"
    - from: "job_radar/profile_manager.py save_profile()"
      to: "backup creation + atomic write"
      via: "backup then temp+rename pattern"
      pattern: "tempfile\\.mkstemp"
---

<objective>
Create the centralized profile_manager.py module with all core profile I/O functionality: custom exception hierarchy, validation logic, atomic file writes (extracted from wizard.py pattern), timestamped backup creation with rotation, and schema versioning with migration support. Also extend paths.py with a backup directory helper.

Purpose: Provides the single source of truth for all profile read/write operations. Once this module exists, Plan 02 can wire wizard.py and search.py to use it, eliminating duplicated logic.

Output: job_radar/profile_manager.py (new module), job_radar/paths.py (extended with get_backup_dir)
</objective>

<execution_context>
@/home/corye/.claude/get-shit-done/workflows/execute-plan.md
@/home/corye/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-profile-infrastructure/24-CONTEXT.md
@.planning/phases/24-profile-infrastructure/24-RESEARCH.md
@job_radar/wizard.py
@job_radar/search.py
@job_radar/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add get_backup_dir() to paths.py and create profile_manager.py exception hierarchy + validation</name>
  <files>job_radar/paths.py, job_radar/profile_manager.py</files>
  <action>
1. In job_radar/paths.py, add a `get_backup_dir()` function after `get_data_dir()`:
   - Returns `get_data_dir() / "backups"` (per user decision: backups in subdirectory next to profile)
   - Creates the directory if it does not exist (`mkdir(parents=True, exist_ok=True)`)
   - Returns a Path object

2. Create job_radar/profile_manager.py with the following structure:

   Module docstring: """Centralized profile I/O with atomic writes, backups, validation, and schema versioning."""

   Imports: json, os, tempfile, logging, pathlib.Path, datetime.datetime
   Logger: `log = logging.getLogger(__name__)`

   Constants:
   - `CURRENT_SCHEMA_VERSION = 1`
   - `MAX_BACKUPS = 10`

   Exception hierarchy (4 classes):
   - `ProfileValidationError(Exception)` — base, stores a `message` attribute
   - `MissingFieldError(ProfileValidationError)` — takes `fields: list[str]`, message like "Missing required field(s): name, core_skills"
   - `InvalidTypeError(ProfileValidationError)` — takes `field: str, expected: str, got: type`, message like "Field 'target_titles' must be non-empty list, got NoneType"
   - `ProfileNotFoundError(ProfileValidationError)` — takes `path: Path`, message includes the file path (per user decision: always include file path)
   - `ProfileCorruptedError(ProfileValidationError)` — takes `path: Path, reason: str`, message includes file path and JSON error detail

   `validate_profile(profile: dict) -> None` function:
   - Raises ProfileValidationError subclasses on failure
   - Checks `isinstance(profile, dict)` first
   - Required fields: ["name", "target_titles", "core_skills"] (these are what the scoring engine needs)
   - Type checks: target_titles must be non-empty list, core_skills must be non-empty list
   - Optional field validation:
     - years_experience: int, 0-50 range
     - comp_floor: int or float, 0-1,000,000 range
     - arrangement: must be list if present
     - min_score: float, 1.0-5.0 range (if present)
   - Use friendly, guiding error tone per user decision (e.g., "Your years_experience value of 55 is out of range -- it must be between 0 and 50.")
   - Always include field name in error messages
   - Unknown fields: silently ignore (per user decision: preserve unknown fields, forward-compatible)
   - Claude's Discretion: report first validation error encountered (stop at first), since friendly messages are detailed enough to fix one at a time
  </action>
  <verify>
Run: `cd /home/corye/Claude/Job-Radar && python -c "from job_radar.profile_manager import validate_profile, ProfileValidationError, MissingFieldError, InvalidTypeError, ProfileNotFoundError, ProfileCorruptedError, CURRENT_SCHEMA_VERSION; print('Imports OK'); validate_profile({'name': 'Test', 'target_titles': ['Dev'], 'core_skills': ['Python']}); print('Valid profile OK')"`
Then verify validation catches errors: `python -c "from job_radar.profile_manager import validate_profile, MissingFieldError; validate_profile({})" 2>&1` should raise MissingFieldError.
Also verify paths: `python -c "from job_radar.paths import get_backup_dir; print(get_backup_dir())"`
  </verify>
  <done>profile_manager.py exists with exception hierarchy and validate_profile() function. paths.py has get_backup_dir(). All imports resolve. Valid profiles pass validation. Invalid profiles raise appropriate exceptions with friendly messages including field names and file paths.</done>
</task>

<task type="auto">
  <name>Task 2: Implement save_profile() with atomic writes, backups, rotation and load_profile() with schema migration</name>
  <files>job_radar/profile_manager.py</files>
  <action>
Add to the existing profile_manager.py created in Task 1:

1. `_create_backup(profile_path: Path) -> Path | None` (private helper):
   - If profile_path does not exist, return None (nothing to back up)
   - Get backup dir from `get_backup_dir()` (import from .paths)
   - Generate filename with human-readable timestamp: `profile_YYYY-MM-DD_HH-MM-SS.json` (per user decision: human-readable timestamps like profile_2026-02-12_14-30-22.json)
   - Use `datetime.now()` (local time, not UTC, for human readability of filenames)
   - Copy current profile to backup (simple file copy, not atomic — backup corruption is recoverable)
   - Wrap in try/except: on failure, log warning but return None (per user decision: backup failure warns but continues, don't block user)
   - Return backup path on success

2. `_rotate_backups(backup_dir: Path, max_backups: int = MAX_BACKUPS) -> None` (private helper):
   - List all `profile_*.json` files in backup_dir using glob
   - Sort by modification time (newest first): `sorted(backups, key=lambda p: p.stat().st_mtime, reverse=True)`
   - Delete all beyond max_backups
   - Wrap each deletion in try/except (silent per user decision — no notification on deletion)

3. `_write_json_atomic(path: Path, data: dict) -> None` (private helper, extracted from wizard.py):
   - Ensure parent directory exists
   - Create temp file in same directory via `tempfile.mkstemp(dir=path.parent, prefix=path.name + ".", suffix=".tmp")`
   - Write JSON with `json.dump(data, f, indent=2, ensure_ascii=False)`
   - Call `f.flush()` then `os.fsync(f.fileno())` before close
   - Atomic rename via `Path(tmp_path).replace(path)`
   - On error: unlink temp file, re-raise
   - This is the SAME pattern from wizard.py lines 145-186, extracted for reuse

4. `save_profile(profile_data: dict, profile_path: Path) -> None` (public):
   - Call `validate_profile(profile_data)` FIRST — never write invalid data
   - Ensure schema_version is set: `profile_data.setdefault("schema_version", CURRENT_SCHEMA_VERSION)`
   - Create backup (if file exists): call `_create_backup(profile_path)`
   - If backup succeeded, print brief "Profile backed up" message (per user decision)
   - If backup failed (returned None and file existed), log warning: "Could not create backup for {profile_path}, continuing with save"
   - Rotate old backups: call `_rotate_backups(get_backup_dir())`
   - Atomic write: call `_write_json_atomic(profile_path, profile_data)`

5. `load_profile(profile_path: Path) -> dict` (public):
   - If file does not exist: raise `ProfileNotFoundError(profile_path)`
   - Try `json.load()`: on JSONDecodeError, raise `ProfileCorruptedError(profile_path, str(e))`
   - Handle schema migration:
     - Get `schema_version = profile.get("schema_version", 0)` (missing = pre-v1.5.0 = version 0)
     - If version 0: set `profile["schema_version"] = CURRENT_SCHEMA_VERSION`, call `save_profile(profile, profile_path)` to auto-save migrated profile (per user decision: auto-save after migration, silent migration)
     - If version > CURRENT_SCHEMA_VERSION: ignore silently, best-effort (per user decision: ignore unknown schema versions)
     - If version == CURRENT_SCHEMA_VERSION: no action needed
   - Call `validate_profile(profile)` — if validation fails, let the exception propagate (caller decides whether to offer wizard recovery per user decision)
   - Return profile dict

IMPORTANT: Do NOT modify validation to strip unknown fields. Unknown fields must be preserved silently per user decision (forward-compatible).

NOTE on backup message: Use `print("Profile backed up")` — brief and simple per user decision. Do NOT use logging for this; it's a user-facing confirmation message.
  </action>
  <verify>
Run a full integration test:
```
cd /home/corye/Claude/Job-Radar && python -c "
from pathlib import Path
import tempfile, json, os

from job_radar.profile_manager import save_profile, load_profile, CURRENT_SCHEMA_VERSION

# Create temp dir for test
with tempfile.TemporaryDirectory() as td:
    p = Path(td) / 'profile.json'

    # Test save
    data = {'name': 'Test', 'target_titles': ['Dev'], 'core_skills': ['Python'], 'custom_field': 'preserved'}
    save_profile(data, p)

    # Verify file exists with schema_version
    loaded = json.loads(p.read_text())
    assert loaded['schema_version'] == CURRENT_SCHEMA_VERSION, f'schema_version wrong: {loaded}'
    assert loaded['custom_field'] == 'preserved', 'custom field lost'

    # Test load
    result = load_profile(p)
    assert result['name'] == 'Test'
    assert result['custom_field'] == 'preserved'

    # Test backup was created on second save
    save_profile(result, p)
    backup_dir = Path(td).parent  # backups go in get_backup_dir()

    print('All profile_manager tests passed!')
"
```
  </verify>
  <done>save_profile() validates, backs up, rotates, and atomically writes. load_profile() reads, migrates schema v0 to v1 with auto-save, and validates. Unknown fields preserved. Backup creates human-readable timestamp files. Rotation keeps 10 most recent. Brief "Profile backed up" message shown to user on save.</done>
</task>

</tasks>

<verification>
1. `python -c "from job_radar.profile_manager import save_profile, load_profile, validate_profile"` -- all public functions importable
2. `python -c "from job_radar.profile_manager import ProfileValidationError, MissingFieldError, InvalidTypeError, ProfileNotFoundError, ProfileCorruptedError"` -- all exceptions importable
3. `python -c "from job_radar.paths import get_backup_dir; print(get_backup_dir())"` -- backup dir resolves
4. Create a test profile, save it, verify schema_version=1 in output JSON
5. Save again, verify backup file created in backups/ with human-readable timestamp
6. Verify unknown fields survive round-trip (save then load)
7. Verify invalid profile (empty dict) raises MissingFieldError with friendly message
</verification>

<success_criteria>
- profile_manager.py exists with load_profile, save_profile, validate_profile, and 5 exception classes
- Atomic write pattern extracted from wizard.py into reusable _write_json_atomic
- Backup creation with human-readable timestamp filenames (profile_YYYY-MM-DD_HH-MM-SS.json)
- Backup rotation keeps 10 most recent, silently deletes older
- Schema versioning: schema_version=1 on every save, migration from v0 on load
- Validation rejects missing required fields and wrong types with friendly error messages
- Unknown fields preserved silently (forward-compatible)
- paths.py extended with get_backup_dir()
</success_criteria>

<output>
After completion, create `.planning/phases/24-profile-infrastructure/24-01-SUMMARY.md`
</output>
