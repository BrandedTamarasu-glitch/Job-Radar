---
phase: 28-gui-foundation-threading
plan: 02
type: execute
wave: 2
depends_on: ["28-01"]
files_modified:
  - job_radar/gui/worker_thread.py
  - job_radar/gui/main_window.py
autonomous: true

must_haves:
  truths:
    - "GUI window remains responsive during simulated 10+ second mock operations (window can be moved/resized)"
    - "Progress updates from worker threads appear correctly in GUI without crashes or freezes"
    - "Cancel button stops the running mock operation and resets the UI"
    - "Error dialog pops up as modal when worker thread encounters an error"
    - "Progress indicator shows source name (e.g. 'Fetching Dice...') as each mock source runs"
  artifacts:
    - path: "job_radar/gui/worker_thread.py"
      provides: "Thread-safe worker with queue communication and Event-based cancellation"
      min_lines: 50
      contains: "threading.Event"
    - path: "job_radar/gui/main_window.py"
      provides: "Queue polling loop, progress display, cancel button, error dialogs"
      contains: "check_queue"
  key_links:
    - from: "job_radar/gui/worker_thread.py"
      to: "job_radar/gui/main_window.py"
      via: "queue.Queue messages (progress, complete, cancelled, error)"
      pattern: "queue\\.put"
    - from: "job_radar/gui/main_window.py"
      to: "job_radar/gui/worker_thread.py"
      via: "threading.Thread(target=worker.run, daemon=True)"
      pattern: "threading\\.Thread"
    - from: "job_radar/gui/main_window.py"
      to: "itself"
      via: ".after(100, self._check_queue) polling loop"
      pattern: "\\.after\\(100"
---

<objective>
Build the non-blocking threading infrastructure with queue-based communication and integrate it into the GUI Search tab with a mock 10+ second operation, progress display, cancel button, and error dialogs.

Purpose: Prove the threading pattern works correctly before Phase 29 integrates real search execution. This is the critical foundation — if threading is wrong, the GUI will crash or freeze.

Output: Worker thread module with queue messaging and cancellation, main window with queue polling loop, progress bar replacing search area during operations, source-name labels, cancel functionality, and modal error dialogs.
</objective>

<execution_context>
@/home/corye/.claude/get-shit-done/workflows/execute-plan.md
@/home/corye/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/28-gui-foundation-threading/28-RESEARCH.md
@.planning/phases/28-gui-foundation-threading/28-01-SUMMARY.md

@job_radar/gui/main_window.py
@job_radar/sources.py (lines 1186-1285 for fetch_all signature and on_progress/on_source_progress callbacks)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create worker thread module with queue-based communication and cancellation</name>
  <files>
    job_radar/gui/worker_thread.py
  </files>
  <action>
Create `job_radar/gui/worker_thread.py` implementing the thread-safe worker pattern from research.

**`MockSearchWorker` class:**
```python
class MockSearchWorker:
    """Simulates a long-running search operation for threading validation.

    Communicates with GUI via queue.Queue. Supports cancellation via
    threading.Event. Will be replaced by real SearchWorker in Phase 29.
    """
```

**`__init__(self, result_queue: queue.Queue, stop_event: threading.Event)`:**
- Store `self._queue = result_queue` and `self._stop_event = stop_event`.
- Define mock sources list: `["Dice", "HN Hiring", "RemoteOK", "We Work Remotely", "Adzuna"]` (5 sources to match real app).

**`run(self)` method (called in worker thread via `threading.Thread(target=worker.run)`):**
- Iterate over mock sources with `enumerate`.
- For each source:
  1. Check `self._stop_event.is_set()` — if True, put `("cancelled",)` on queue and return.
  2. Put `("progress", source_name, current_index + 1, total_sources)` on queue.
  3. Sleep for 2.5 seconds (simulates network fetch — 5 sources x 2.5s = 12.5s total, satisfying 10+ second requirement).
  4. Check stop_event again after sleep.
- After all sources complete: put `("complete", total_sources)` on queue.
- Wrap entire run in try/except: on Exception, put `("error", str(e))` on queue.

**`cancel(self)` method:**
- `self._stop_event.set()`

**`MockErrorWorker` class (for testing error handling):**
- Same interface as MockSearchWorker but raises an exception after 2 sources.
- Put `("error", "Simulated network error: Connection refused")` on queue.

**Module-level convenience function `create_mock_worker(result_queue)`:**
- Creates a `threading.Event`, creates `MockSearchWorker(result_queue, stop_event)`.
- Returns `(worker, threading.Thread(target=worker.run, daemon=True))`.
- The caller starts the thread.

Key rules from research (enforce in implementation):
- NEVER update GUI widgets from this module — only put messages on the queue.
- ALWAYS use daemon=True for worker threads.
- Use cooperative cancellation (check stop_event periodically), NEVER try to kill threads.
  </action>
  <verify>
Run a standalone test:
```python
python -c "
import queue, time
from job_radar.gui.worker_thread import create_mock_worker
q = queue.Queue()
worker, thread = create_mock_worker(q)
thread.start()
msgs = []
while thread.is_alive() or not q.empty():
    try:
        msgs.append(q.get(timeout=0.5))
    except:
        pass
print(f'Messages received: {len(msgs)}')
print(f'Types: {[m[0] for m in msgs]}')
assert any(m[0] == 'complete' for m in msgs), 'Missing complete message'
assert any(m[0] == 'progress' for m in msgs), 'Missing progress messages'
print('Worker thread test PASSED')
"
```
  </verify>
  <done>
MockSearchWorker runs for 12.5+ seconds across 5 mock sources, sends progress/complete/error messages via queue.Queue, supports cancellation via threading.Event, and never touches GUI widgets.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate threading into Search tab with progress display, cancel, and error dialogs</name>
  <files>
    job_radar/gui/main_window.py
  </files>
  <action>
Modify `main_window.py` (created in Plan 01) to add queue polling, progress display, and threading integration in the Search tab.

**1. Add imports at top:**
- `import queue`, `import threading`
- `from job_radar.gui.worker_thread import create_mock_worker`

**2. Add instance attributes in `MainWindow.__init__`:**
- `self._queue = queue.Queue()` — shared message queue.
- `self._worker = None` — reference to current worker (for cancellation).
- `self._worker_thread = None` — reference to current thread.
- Start queue polling: `self._check_queue()` at end of `__init__`.

**3. Add `_check_queue(self)` method (runs in main GUI thread):**
- Process all pending messages from `self._queue` using `get_nowait()` in a while loop.
- Message handling:
  - `("progress", source, current, total)` → call `self._update_progress(source, current, total)`.
  - `("complete", total)` → call `self._on_search_complete(total)`.
  - `("cancelled",)` → call `self._on_search_cancelled()`.
  - `("error", message)` → call `self._show_error_dialog(message)` and reset UI.
- Catch `queue.Empty` to break the while loop.
- Re-schedule: `self.after(100, self._check_queue)` in finally block.

**4. Expand `_build_search_tab(self, parent)` method:**

Replace the placeholder content with a proper search area using grid layout on `parent`:

- **search_content_frame**: A frame that holds either the idle state or the progress state. Store as `self._search_content`.
- **Idle state** (`self._show_search_idle()`):
  - "Run Search" button: `CTkButton`, stored as `self._search_button`. Disabled if no profile (with red warning label below: "Profile required to run search"). Enabled if profile exists.
  - Command: `self._start_mock_search`.
  - Center the button vertically and horizontally in the frame.
- **Progress state** (`self._show_search_progress()`):
  - Replaces the idle content in `self._search_content` frame.
  - Progress label: `CTkLabel` showing "Fetching {source}..." — stored as `self._progress_label`.
  - Progress bar: `CTkProgressBar` in determinate mode, stored as `self._progress_bar`. Set initial value to 0.
  - Progress count: `CTkLabel` showing "Source X of Y" — stored as `self._progress_count`.
  - Cancel button: `CTkButton` with text "Cancel", command `self._cancel_search`.
  - All centered vertically in the frame.

**5. Add `_start_mock_search(self)` method:**
- Clear the search area and show progress state: `self._show_search_progress()`.
- Create worker: `self._worker, self._worker_thread = create_mock_worker(self._queue)`.
- Start thread: `self._worker_thread.start()`.

**6. Add `_cancel_search(self)` method:**
- If `self._worker`: `self._worker.cancel()`.

**7. Add `_update_progress(self, source, current, total)` method:**
- Update `self._progress_label.configure(text=f"Fetching {source}...")`.
- Update `self._progress_bar.set(current / total)`.
- Update `self._progress_count.configure(text=f"Source {current} of {total}")`.

**8. Add `_on_search_complete(self, total)` method:**
- Show completion briefly: update label to "Search complete!" and bar to 1.0.
- After 2 seconds, reset to idle: `self.after(2000, self._show_search_idle)`.

**9. Add `_on_search_cancelled(self)` method:**
- Update label to "Search cancelled".
- After 1.5 seconds, reset to idle: `self.after(1500, self._show_search_idle)`.
- Clear worker references.

**10. Add `_show_error_dialog(self, message)` method:**
- Create `CTkToplevel` modal dialog (per user decision: errors as popup dialogs).
- Configure: `dialog.title("Error")`, `dialog.geometry("400x200")`.
- Content: `CTkLabel` with the error message, wraplength=350.
- "OK" button to close: `dialog.destroy`.
- Make modal: `dialog.transient(self)`, `dialog.grab_set()`.
- Also reset search UI to idle state.

**11. Helper methods `_show_search_idle(self)` and `_show_search_progress(self)`:**
- These toggle between the two UI states by destroying children of `self._search_content` and rebuilding.
- `_show_search_idle`: Creates the Run Search button (or disabled + warning).
- `_show_search_progress`: Creates progress label, bar, count label, cancel button.
- Clear worker references when returning to idle.

**Key threading safety rules (MUST follow):**
- ALL widget updates happen in `_check_queue` and its callees (main thread only).
- Worker thread ONLY puts messages on the queue — never touches widgets.
- Daemon threads (`daemon=True`) so app exits cleanly.
  </action>
  <verify>
1. Run `python -c "from job_radar.gui.main_window import MainWindow; print('Import OK')"` — no import errors.
2. Manual verification (quick visual check): Run `python -c "from job_radar.gui.main_window import launch_gui; launch_gui()"` — window opens, navigate to Search tab, click Run Search, verify:
   - Progress bar animates and source names change every ~2.5 seconds.
   - Window remains movable/resizable during operation.
   - Cancel button stops the operation.
   - After completion, UI resets to idle state.
  </verify>
  <done>
Queue polling loop runs every 100ms in the main GUI thread. Mock search runs 12.5+ seconds across 5 sources in a worker thread. Progress bar and source labels update in real-time. Cancel button stops the operation. Error dialog pops up as modal. Window stays responsive throughout — no freezes.
  </done>
</task>

</tasks>

<verification>
1. Import test: `python -c "from job_radar.gui.worker_thread import MockSearchWorker, create_mock_worker; print('OK')"`
2. Worker standalone test: Run the queue-based test from Task 1 verify section
3. Threading safety: No direct widget access in worker_thread.py — grep confirms: `grep -c "configure\|pack\|grid\|place" job_radar/gui/worker_thread.py` returns 0
4. Queue polling: `grep "after(100" job_radar/gui/main_window.py` confirms .after() scheduling
5. Daemon threads: `grep "daemon=True" job_radar/gui/worker_thread.py` confirms daemon flag
</verification>

<success_criteria>
- MockSearchWorker runs 12.5+ seconds (5 sources x 2.5s) in background thread
- Queue messages: progress, complete, cancelled, error — all handled in main thread
- Progress bar shows determinate progress (X/5) with source name labels
- Cancel button triggers threading.Event and worker stops cooperatively
- Error dialog is modal (blocks parent window)
- GUI window remains responsive (movable, resizable) during entire mock operation
- No Tcl/Tk thread safety errors
</success_criteria>

<output>
After completion, create `.planning/phases/28-gui-foundation-threading/28-02-SUMMARY.md`
</output>
