---
phase: 08-entry-point-integration
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - tests/test_entry_integration.py
autonomous: true

must_haves:
  truths:
    - "Profile path precedence is tested: CLI --profile overrides config.json profile_path overrides default path"
    - "load_profile_with_recovery triggers wizard on missing profile"
    - "load_profile_with_recovery backs up corrupt profile and triggers wizard"
    - "load_profile_with_recovery respects max retry limit (no infinite loop)"
    - "--validate-profile flag validates and exits without search"
    - "--no-wizard flag skips wizard in __main__.py first-run check"
    - "Legacy v1.0 config (no profile_path) falls back to default profile location"
  artifacts:
    - path: "tests/test_entry_integration.py"
      provides: "Integration tests for Phase 8 entry point wiring"
      min_lines: 100
  key_links:
    - from: "tests/test_entry_integration.py"
      to: "job_radar/search.py"
      via: "imports load_profile_with_recovery, parse_args"
      pattern: "from job_radar.search import"
    - from: "tests/test_entry_integration.py"
      to: "job_radar/config.py"
      via: "tests KNOWN_KEYS includes profile_path"
      pattern: "from job_radar.config import"
---

<objective>
Test all Phase 8 integration: profile path precedence, load_profile_with_recovery flows, developer flags, and backward compatibility.

Purpose: Verify the wizard-to-search pipeline works correctly under all conditions (normal flow, corrupt profile, missing profile, CLI override, legacy config).

Output: tests/test_entry_integration.py with comprehensive test coverage for Phase 8 changes.
</objective>

<execution_context>
@/Users/coryebert/.claude/get-shit-done/workflows/execute-plan.md
@/Users/coryebert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-entry-point-integration/08-CONTEXT.md
@.planning/phases/08-entry-point-integration/08-RESEARCH.md
@.planning/phases/08-entry-point-integration/08-01-SUMMARY.md

Source files under test:
@job_radar/config.py
@job_radar/search.py
@job_radar/__main__.py
@tests/test_config.py
@tests/test_wizard.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create integration tests for entry point wiring</name>
  <files>tests/test_entry_integration.py</files>
  <action>
  Create `tests/test_entry_integration.py` with the following test cases using pytest and pytest-mock (mocker fixture). Use tmp_path fixture for isolated file system operations.

  **Test Group 1: Config profile_path recognition (3 tests)**

  1. `test_config_known_keys_includes_profile_path` - Assert "profile_path" is in KNOWN_KEYS from config.py
  2. `test_config_loads_profile_path_from_json` - Write a config.json with `{"profile_path": "/some/path.json", "min_score": 3.0}` to tmp_path, call `load_config(str(tmp_path / "config.json"))`, assert result contains `profile_path` key
  3. `test_config_legacy_without_profile_path` - Write a v1.0 config `{"min_score": 2.5, "new_only": true}` to tmp_path, call load_config(), assert result has min_score and new_only but NOT profile_path

  **Test Group 2: load_profile_with_recovery (6 tests)**

  4. `test_recovery_valid_profile_returns_dict` - Write a valid profile.json with name, target_titles, core_skills to tmp_path. Call `load_profile_with_recovery(str(path))`. Assert returns dict with correct name.
  5. `test_recovery_missing_profile_triggers_wizard` - Provide nonexistent path. Mock `job_radar.wizard.run_setup_wizard` to return True and create a valid profile.json at the expected location. Assert wizard was called. (Use mocker.patch with side_effect that creates the file then returns True)
  6. `test_recovery_corrupt_json_backs_up_and_triggers_wizard` - Write invalid JSON (`{corrupt}`) to a file. Mock wizard to create valid profile. Call load_profile_with_recovery(). Assert `.bak` file exists, wizard was called, returns valid profile.
  7. `test_recovery_missing_fields_backs_up_and_triggers_wizard` - Write valid JSON but missing required fields `{"name": "Test"}` (no target_titles, no core_skills). Mock wizard. Assert .bak exists and wizard called.
  8. `test_recovery_max_retry_exits` - Mock wizard to always return True but write an invalid profile each time. Assert sys.exit(1) is called after 2 retries (use `pytest.raises(SystemExit)` with code=1).
  9. `test_recovery_wizard_cancelled_exits` - Missing profile, mock wizard to return False (user cancelled). Assert sys.exit(1) via `pytest.raises(SystemExit)`.

  **Test Group 3: Profile path precedence in parse_args (3 tests)**

  10. `test_parse_args_cli_profile_overrides_config` - Call `parse_args({"profile_path": "/config/path.json"})` with sys.argv set to `["prog", "--profile", "/cli/path.json"]`. Assert `args.profile == "/cli/path.json"`.
  11. `test_parse_args_config_profile_path_used_as_default` - Call `parse_args({"profile_path": "/config/path.json"})` with sys.argv set to `["prog"]` (no --profile flag). Assert `args.profile` is None (set_defaults applies to argparse dest "profile" only if key matches). Note: config uses `profile_path` key but argparse dest is `profile`, so set_defaults with `profile_path` does NOT set `profile`. The fallback logic in main() handles this - test that args.profile is None and the resolution logic in main() would use get_data_dir().
  12. `test_parse_args_no_wizard_flag` - Call `parse_args()` with sys.argv `["prog", "--no-wizard"]`. Assert `args.no_wizard is True`.

  **Test Group 4: Developer flags (2 tests)**

  13. `test_validate_profile_valid_exits_zero` - Create a valid profile.json in tmp_path. Use `mocker.patch("sys.argv", ["prog", "--validate-profile", str(path)])`. Import and call search.main(). Assert SystemExit with code 0. (Capture stdout and verify "Profile valid" message)
  14. `test_validate_profile_invalid_exits_one` - Write invalid profile (empty JSON object). Patch sys.argv with --validate-profile pointing to it. Assert SystemExit with code 1.

  **Test patterns to follow:**
  - Import from `job_radar.config` and `job_radar.search` directly
  - Use `mocker.patch` for wizard mocking (same pattern as test_wizard.py: patch `job_radar.wizard.run_setup_wizard`)
  - Use `tmp_path` for all file operations
  - Use `capsys` for stdout capture where needed
  - Patch `job_radar.paths.get_data_dir` to return tmp_path where needed (same pattern as test_wizard.py)
  - Use `monkeypatch.setattr(sys, "argv", [...])` for argument parsing tests
  - For test_recovery tests: The function may call sys.exit - wrap in `pytest.raises(SystemExit)` where exit is expected
  - For wizard mock side_effect: create valid profile.json at expected path then return True
  </action>
  <verify>
  ```bash
  python -m pytest tests/test_entry_integration.py -v
  ```
  All tests pass. Then run full suite:
  ```bash
  python -m pytest tests/ -x -q
  ```
  No regressions.
  </verify>
  <done>
  14 tests covering: config profile_path recognition (3), load_profile_with_recovery flows (6), parse_args precedence (3), developer flags (2). All tests pass. Full test suite has no regressions.
  </done>
</task>

</tasks>

<verification>
Full test suite passes with no regressions:
```bash
python -m pytest tests/ -v
```

New test file specifically:
```bash
python -m pytest tests/test_entry_integration.py -v --tb=short
```

Verify test count:
```bash
python -m pytest tests/test_entry_integration.py --co -q | tail -1
```
Should show 14 tests collected.
</verification>

<success_criteria>
1. tests/test_entry_integration.py exists with 14 test cases
2. All 14 tests pass
3. Full test suite (all test files) passes with no regressions
4. Tests cover: config recognition, recovery flows, precedence, dev flags, backward compatibility
5. No external dependencies added beyond existing pytest + pytest-mock
</success_criteria>

<output>
After completion, create `.planning/phases/08-entry-point-integration/08-02-SUMMARY.md`
</output>
