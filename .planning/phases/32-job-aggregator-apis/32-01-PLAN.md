---
phase: 32-job-aggregator-apis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - job_radar/sources.py
  - job_radar/rate_limits.py
autonomous: true

must_haves:
  truths:
    - "fetch_jsearch() returns JobResult list with source set to original publisher (LinkedIn, Indeed, Glassdoor)"
    - "fetch_usajobs() returns JobResult list with source 'USAJobs (Federal)' and handles nested response structure"
    - "JSearch and USAJobs sources share correct rate limiter backends via BACKEND_API_MAP"
    - "Source display names include all new sources for progress callbacks"
  artifacts:
    - path: "job_radar/sources.py"
      provides: "fetch_jsearch, map_jsearch_to_job_result, fetch_usajobs, map_usajobs_to_job_result functions"
      contains: "def fetch_jsearch"
    - path: "job_radar/rate_limits.py"
      provides: "BACKEND_API_MAP entries for linkedin/indeed/glassdoor->jsearch and usajobs->usajobs, RATE_LIMITS defaults for jsearch and usajobs"
      contains: "linkedin.*jsearch"
  key_links:
    - from: "job_radar/sources.py"
      to: "job_radar/rate_limits.py"
      via: "check_rate_limit() calls using 'jsearch' and 'usajobs' source names"
      pattern: "check_rate_limit.*jsearch"
    - from: "job_radar/sources.py"
      to: "job_radar/api_config.py"
      via: "get_api_key() calls for JSEARCH_API_KEY, USAJOBS_API_KEY, USAJOBS_EMAIL"
      pattern: "get_api_key.*JSEARCH"
---

<objective>
Implement JSearch and USAJobs fetch functions with response mapping, rate limiter configuration, and source display names.

Purpose: Create the core API integration layer that retrieves job listings from JSearch (covering LinkedIn, Indeed, Glassdoor) and USAJobs (federal jobs), mapping responses to the existing JobResult dataclass with proper source attribution.

Output: Two new fetch functions (fetch_jsearch, fetch_usajobs) and two mapping functions (map_jsearch_to_job_result, map_usajobs_to_job_result) in sources.py, plus BACKEND_API_MAP and RATE_LIMITS updates in rate_limits.py.
</objective>

<execution_context>
@/home/corye/.claude/get-shit-done/workflows/execute-plan.md
@/home/corye/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/32-job-aggregator-apis/32-RESEARCH.md
@.planning/phases/31-rate-limiter-infrastructure/31-01-SUMMARY.md
@job_radar/sources.py
@job_radar/rate_limits.py
@job_radar/api_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement JSearch and USAJobs fetch functions with response mapping</name>
  <files>job_radar/sources.py</files>
  <action>
Add two new fetch functions and their response mappers to sources.py, following the existing fetch_adzuna/map_adzuna_to_job_result pattern.

**JSearch (fetch_jsearch):**
- Endpoint: `https://jsearch.p.rapidapi.com/search`
- Headers: `X-RapidAPI-Key` (exact case required per RapidAPI docs), `X-RapidAPI-Host: jsearch.p.rapidapi.com`
- API key env var: `JSEARCH_API_KEY` via `get_api_key("JSEARCH_API_KEY", "JSearch")`
- Rate limit check: `check_rate_limit("jsearch", verbose=verbose)` — uses "jsearch" directly since BACKEND_API_MAP maps display sources to jsearch backend
- Parameters: `query` (search terms), `page` ("1"), `num_pages` ("1"), `date_posted` ("week")
- If location provided: add `location` param
- Response: `data.get("data", [])` for items array
- Auth error handling: log error suggesting `--setup-apis` on 401/403
- Return `list[JobResult]`

**map_jsearch_to_job_result:**
- Required fields: `job_title`, `employer_name`, `job_apply_link` — return None if any missing
- Source attribution (LOCKED DECISION): Use `job_publisher` field for source name, NOT "JSearch"
  - Whitelist: `JSEARCH_KNOWN_SOURCES = {"LinkedIn", "Indeed", "Glassdoor"}`
  - If publisher in whitelist, use it directly (e.g., source="LinkedIn")
  - If publisher not in whitelist, use "JSearch (Other)"
  - Log unknown publishers at debug level for future expansion
- Location: `job_is_remote` -> "Remote"; else `job_city, job_state`; fallback to `job_country`
- Salary: `job_min_salary`, `job_max_salary` (format same as Adzuna pattern)
- Description: `job_description` -> `strip_html_and_normalize()`, truncate to 500 chars
- Date: `job_posted_at_datetime_utc[:10]` (extract YYYY-MM-DD)
- Employment type: `job_employment_type`
- Arrangement: call `_parse_arrangement()` on title + description + location

**USAJobs (fetch_usajobs):**
- Endpoint: `https://data.usajobs.gov/api/search`
- Headers (CRITICAL per research pitfall #2):
  - `Host: data.usajobs.gov`
  - `User-Agent: {email}` — MUST contain email from API registration
  - `Authorization-Key: {api_key}`
- API key env vars: `USAJOBS_API_KEY` via `get_api_key("USAJOBS_API_KEY", "USAJobs")` AND `USAJOBS_EMAIL` via `get_api_key("USAJOBS_EMAIL", "USAJobs")` — both required
- Rate limit check: `check_rate_limit("usajobs", verbose=verbose)`
- Parameters: `Keyword` (query), `ResultsPerPage` ("50")
- If location: `LocationName` param
- Accept optional `profile` dict for federal filters:
  - `gs_grade_min` -> `PayGradeLow` (format as 2-digit string, e.g., "07")
  - `gs_grade_max` -> `PayGradeHigh`
  - `preferred_agencies` -> `Organization` (semicolon-delimited)
  - Security clearance: NOT available as API parameter (per research) — skip
- Response: `data.get("SearchResult", {}).get("SearchResultItems", [])` (nested structure per pitfall #5)
- Auth error handling: same pattern as JSearch

**map_usajobs_to_job_result:**
- Access nested `MatchedObjectDescriptor` from each item
- Required: `PositionTitle`, `OrganizationName`, `PositionURI` — return None if missing
- Source: Always `"USAJobs (Federal)"` (LOCKED DECISION — display as "USAJobs (Federal)")
- Company: `OrganizationName` (no "(Federal)" suffix on company — source field handles that)
- Location: `PositionLocationDisplay` or fallback to first item in `PositionLocation` array
- Salary: `PositionRemuneration[0]` -> `MinimumRange`, `MaximumRange` (cast to float)
- Description: `UserArea.Details.JobSummary` -> strip/normalize/truncate
- Date: `PublicationStartDate[:10]`
- Employment type: `PositionSchedule[0].Name` with safe indexing

**Also update `_SOURCE_DISPLAY_NAMES` dict:**
```python
"linkedin": "LinkedIn",
"indeed": "Indeed",
"glassdoor": "Glassdoor",
"jsearch_other": "JSearch (Other)",
"usajobs": "USAJobs (Federal)",
```

Note: JSearch results use individual source names (linkedin, indeed, glassdoor) which map to display names. The `source` field on JobResult will use lowercase versions matching these keys.

**Important source name convention:**
- JSearch results get source = publisher.lower() if in known set (e.g., "linkedin", "indeed", "glassdoor")
- JSearch unknown publishers get source = "jsearch_other"
- USAJobs results get source = "usajobs"
- This matches BACKEND_API_MAP keys and _SOURCE_DISPLAY_NAMES keys
  </action>
  <verify>
Run `python -c "from job_radar.sources import fetch_jsearch, fetch_usajobs, map_jsearch_to_job_result, map_usajobs_to_job_result; print('imports OK')"` to verify functions exist and import without errors. Run `python -c "from job_radar.sources import _SOURCE_DISPLAY_NAMES; assert 'linkedin' in _SOURCE_DISPLAY_NAMES; assert 'usajobs' in _SOURCE_DISPLAY_NAMES; print('display names OK')"` to verify display name updates.
  </verify>
  <done>
fetch_jsearch and fetch_usajobs functions exist in sources.py, follow Adzuna pattern (credential check, rate limit check, build URL, fetch, map results), handle auth errors gracefully, and return list[JobResult]. map_jsearch_to_job_result uses job_publisher for source attribution with known source whitelist. map_usajobs_to_job_result handles nested MatchedObjectDescriptor structure. _SOURCE_DISPLAY_NAMES includes all new source keys.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update rate limiter configuration for JSearch and USAJobs backends</name>
  <files>job_radar/rate_limits.py</files>
  <action>
Update BACKEND_API_MAP and rate limit defaults in rate_limits.py.

**BACKEND_API_MAP updates:**
Uncomment and add the JSearch and USAJobs mappings that Phase 31 prepared:
```python
BACKEND_API_MAP = {
    "adzuna": "adzuna",
    "authentic_jobs": "authentic_jobs",
    # JSearch aggregator — all three share same rate limiter instance
    "linkedin": "jsearch",
    "indeed": "jsearch",
    "glassdoor": "jsearch",
    "jsearch_other": "jsearch",
    # USAJobs — single source
    "usajobs": "usajobs",
}
```

**Rate limit defaults:**
Add conservative defaults for jsearch and usajobs to the hardcoded defaults dict inside `_load_rate_limits()`:
```python
defaults = {
    "adzuna": [...existing...],
    "authentic_jobs": [...existing...],
    "jsearch": [Rate(100, Duration.MINUTE)],      # 100 req/min (RapidAPI free tier)
    "usajobs": [Rate(60, Duration.MINUTE)],        # 60 req/min (conservative for gov API)
}
```

This ensures:
- All JSearch display sources (linkedin, indeed, glassdoor, jsearch_other) share one rate limiter
- USAJobs has its own limiter
- Users can override via config.json (already supported from Phase 31 Plan 02)
  </action>
  <verify>
Run `python -c "from job_radar.rate_limits import BACKEND_API_MAP, RATE_LIMITS; assert BACKEND_API_MAP['linkedin'] == 'jsearch'; assert BACKEND_API_MAP['usajobs'] == 'usajobs'; assert 'jsearch' in RATE_LIMITS; assert 'usajobs' in RATE_LIMITS; print('rate limits OK')"` to verify configuration.
  </verify>
  <done>
BACKEND_API_MAP maps linkedin/indeed/glassdoor/jsearch_other to "jsearch" backend and usajobs to "usajobs" backend. RATE_LIMITS includes conservative defaults for both new backends. Shared rate limiter infrastructure from Phase 31 automatically pools requests across JSearch display sources.
  </done>
</task>

</tasks>

<verification>
1. All new functions import without errors
2. _SOURCE_DISPLAY_NAMES includes linkedin, indeed, glassdoor, jsearch_other, usajobs
3. BACKEND_API_MAP correctly maps display sources to backend APIs
4. RATE_LIMITS has defaults for jsearch and usajobs
5. Full test suite passes with no regressions: `cd /home/corye/Claude/Job-Radar && python -m pytest tests/ -x -q`
</verification>

<success_criteria>
- fetch_jsearch() and fetch_usajobs() exist and follow established fetch pattern
- Response mappers handle source attribution correctly (LinkedIn/Indeed/Glassdoor from JSearch, USAJobs (Federal) from USAJobs)
- Rate limiter configuration shares backend across JSearch sources
- All existing 460 tests pass with zero regressions
</success_criteria>

<output>
After completion, create `.planning/phases/32-job-aggregator-apis/32-01-SUMMARY.md`
</output>
