---
phase: 31-rate-limiter-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - job_radar/config.py
  - job_radar/rate_limits.py
  - tests/test_config.py
  - tests/test_rate_limits.py
autonomous: true

must_haves:
  truths:
    - "Rate limit configurations can be loaded from config.json instead of hardcoded values"
    - "Users can override default rate limits for API sources via config file"
    - "Invalid rate limit configs show clear error messages with recovery instructions"
  artifacts:
    - path: "job_radar/config.py"
      provides: "Rate limit config loading from config.json"
      contains: "rate_limits"
      exports: ["load_config", "KNOWN_KEYS"]
    - path: "job_radar/rate_limits.py"
      provides: "Dynamic rate limit loading from config"
      contains: "load_config"
    - path: "tests/test_config.py"
      provides: "Tests for rate limit config validation"
      min_lines: 50
  key_links:
    - from: "job_radar/rate_limits.py"
      to: "job_radar/config"
      via: "load_config() to get rate_limits dict"
      pattern: "from.*config import|load_config"
    - from: "RATE_LIMITS initialization"
      to: "config.json"
      via: "merge config file overrides with defaults"
      pattern: "config\\.get.*rate_limits"
---

<objective>
Enable dynamic rate limit configuration from config.json instead of hardcoded values.

Purpose: Allow users to customize rate limits for their API tier (e.g., premium Adzuna users can increase limits) without editing source code.

Output: Rate limits loadable from config.json with validation and clear error messages for invalid configs.
</objective>

<execution_context>
@/home/corye/.claude/get-shit-done/workflows/execute-plan.md
@/home/corye/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Updated infrastructure from Plan 01
@.planning/phases/31-rate-limiter-infrastructure/31-01-SUMMARY.md

# Current implementation
@job_radar/config.py
@job_radar/rate_limits.py
@tests/test_config.py
</context>

<tasks>

<task type="auto">
  <name>Add rate limit config loading to config.py and rate_limits.py</name>
  <files>job_radar/config.py, job_radar/rate_limits.py, tests/test_config.py, tests/test_rate_limits.py</files>
  <action>
Extend config.py to recognize "rate_limits" key, then modify rate_limits.py to load and merge config file overrides with hardcoded defaults.

Implementation:

**1. Update config.py:**

- Add "rate_limits" to KNOWN_KEYS set (line 21)
- No other changes needed (load_config already handles arbitrary keys)

**2. Update rate_limits.py:**

- Import load_config at top: `from .config import load_config`

- Replace hardcoded RATE_LIMITS dict initialization with dynamic loading:
```python
def _load_rate_limits() -> dict:
    """Load rate limits from config file with fallback to defaults.

    Config format in config.json:
    {
      "rate_limits": {
        "adzuna": [{"limit": 200, "interval": 60}],
        "jsearch": [{"limit": 100, "interval": 60}, {"limit": 500, "interval": 3600}]
      }
    }

    Returns dict mapping backend API names to Rate objects.
    """
    # Hardcoded defaults (conservative)
    defaults = {
        "adzuna": [Rate(100, Duration.MINUTE), Rate(1000, Duration.HOUR)],
        "authentic_jobs": [Rate(60, Duration.MINUTE)],
    }

    # Load config file
    config = load_config()
    config_limits = config.get("rate_limits", {})

    if not isinstance(config_limits, dict):
        log.warning("Config rate_limits must be a dict, got %s - using defaults", type(config_limits).__name__)
        return defaults

    # Merge config overrides with defaults
    result = defaults.copy()
    for backend_api, rate_configs in config_limits.items():
        if not isinstance(rate_configs, list):
            log.warning("Config rate_limits[%s] must be a list, got %s - skipping", backend_api, type(rate_configs).__name__)
            continue

        rates = []
        for rate_config in rate_configs:
            if not isinstance(rate_config, dict):
                log.warning("Config rate_limits[%s] entry must be a dict - skipping", backend_api)
                continue

            limit = rate_config.get("limit")
            interval = rate_config.get("interval")

            if not isinstance(limit, int) or limit <= 0:
                log.warning("Config rate_limits[%s] limit must be positive int - skipping", backend_api)
                continue

            if not isinstance(interval, (int, float)) or interval <= 0:
                log.warning("Config rate_limits[%s] interval must be positive number - skipping", backend_api)
                continue

            rates.append(Rate(limit, interval))

        if rates:
            result[backend_api] = rates
            log.debug("Loaded custom rate limits for %s: %d rate(s)", backend_api, len(rates))

    return result

RATE_LIMITS = _load_rate_limits()
```

- Update module docstring to document config.json format

**3. Add tests:**

- tests/test_config.py:
  - test_config_recognizes_rate_limits_key() - verify "rate_limits" in KNOWN_KEYS

- tests/test_rate_limits.py:
  - test_rate_limits_loaded_from_config(tmp_path, monkeypatch) - write config.json, verify custom limits used
  - test_rate_limits_invalid_config_uses_defaults(tmp_path, monkeypatch) - verify graceful fallback
  - test_rate_limits_config_override_merges_with_defaults(tmp_path, monkeypatch) - verify only specified backends override

Why this design:
- Config overrides are opt-in (missing config = defaults work)
- Invalid configs log warnings but don't crash (graceful degradation)
- Config format matches pyrate-limiter Rate structure (limit + interval in seconds)
- Validation ensures only valid Rate objects are created
- Per-backend configuration (not per-source) aligns with shared limiter design from Plan 01
  </action>
  <verify>
Run tests verifying config loading:
```bash
python -m pytest tests/test_config.py::test_config_recognizes_rate_limits_key -v
python -m pytest tests/test_rate_limits.py::test_rate_limits_loaded_from_config -v
python -m pytest tests/test_rate_limits.py::test_rate_limits_invalid_config_uses_defaults -v
python -m pytest tests/test_rate_limits.py -v
python -m pytest tests/test_config.py -v
```

Manual test with config file:
```bash
mkdir -p ~/.job-radar
cat > ~/.job-radar/config.json << 'EOF'
{
  "rate_limits": {
    "adzuna": [{"limit": 200, "interval": 60}]
  }
}
EOF
python -c "from job_radar.rate_limits import RATE_LIMITS; print(RATE_LIMITS)"
# Should show custom adzuna limit
```
  </verify>
  <done>
Rate limits loaded from config.json when present. Invalid configs show warnings and use defaults. Tests verify loading, validation, and fallback behavior. KNOWN_KEYS includes "rate_limits". Manual config test shows custom limits applied.
  </done>
</task>

</tasks>

<verification>
1. Run full test suite - no regressions: `python -m pytest tests/ -v`
2. Verify config.json example in documentation is valid
3. Test invalid config formats (non-dict, non-list, negative values) - should warn and use defaults
4. Verify hardcoded defaults still work when config file missing
5. Check log output shows "Loaded custom rate limits for X" when config present
</verification>

<success_criteria>
1. Rate limit configurations loadable from config.json (INFRA-03)
2. Invalid configs show clear warnings and fall back to defaults
3. Config format documented in rate_limits.py module docstring
4. All tests pass including new config loading tests
5. Backward compatible - missing config uses hardcoded defaults
</success_criteria>

<output>
After completion, create `.planning/phases/31-rate-limiter-infrastructure/31-02-SUMMARY.md`
</output>
