---
phase: 36-gui-uninstall-feature
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - job_radar/uninstaller.py
  - tests/test_uninstaller.py
autonomous: true

must_haves:
  truths:
    - "Backup ZIP contains only profile.json and config.json from data directory"
    - "Deletion removes all files in the data directory with best-effort error collection"
    - "Platform-specific cleanup scripts are generated for macOS, Windows, and Linux"
    - "Rate limiter connections are cleaned up before data deletion"
    - "get_uninstall_paths() returns accurate list of paths with human-readable descriptions"
  artifacts:
    - path: "job_radar/uninstaller.py"
      provides: "Core uninstall logic: backup, deletion, cleanup scripts, path enumeration"
      min_lines: 150
    - path: "tests/test_uninstaller.py"
      provides: "Unit tests for backup, deletion, path enumeration, cleanup scripts"
      min_lines: 100
  key_links:
    - from: "job_radar/uninstaller.py"
      to: "job_radar/paths.py"
      via: "get_data_dir(), get_log_file(), is_frozen()"
      pattern: "from .paths import get_data_dir"
    - from: "job_radar/uninstaller.py"
      to: "job_radar/rate_limits.py"
      via: "_cleanup_connections() called before deletion"
      pattern: "from .rate_limits import _cleanup_connections"
---

<objective>
Create the core uninstaller module with backup, deletion, path enumeration, and platform-specific cleanup script generation.

Purpose: Provide testable backend logic for the GUI uninstall feature. All file operations, backup creation, and cleanup script generation are isolated in a single module that the GUI dialogs will call.

Output: `job_radar/uninstaller.py` with pure functions for backup, deletion, and cleanup; `tests/test_uninstaller.py` with comprehensive unit tests.
</objective>

<execution_context>
@/Users/coryebert/.claude/get-shit-done/workflows/execute-plan.md
@/Users/coryebert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/36-gui-uninstall-feature/36-CONTEXT.md
@.planning/phases/36-gui-uninstall-feature/36-RESEARCH.md
@job_radar/paths.py
@job_radar/rate_limits.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create uninstaller.py with backup, deletion, path enumeration, and cleanup scripts</name>
  <files>job_radar/uninstaller.py</files>
  <action>
Create `job_radar/uninstaller.py` with the following functions:

**get_uninstall_paths() -> list[tuple[str, str]]:**
- Return list of (path_string, description) tuples for all app data that will be deleted
- Include: data directory contents (profile.json, config.json, backups/, rate limit DBs, cache), log file (~/job-radar-error.log)
- Use get_data_dir() from paths.py for data directory, get_log_file() for log path
- Each entry has human-readable description (e.g., "profile.json - Your search preferences")
- Only include paths that actually exist on disk (check with Path.exists())

**create_backup(save_path: str) -> None:**
- Create ZIP file at save_path containing only profile.json and config.json from get_data_dir()
- Use zipfile.ZipFile with ZIP_DEFLATED compression
- Use arcname to store files at root of ZIP (no directory nesting)
- Skip files that don't exist (don't error if profile.json missing)
- Raise exception on write failure (caller handles error presentation)

**delete_app_data() -> list[tuple[str, str]]:**
- First call rate_limits._cleanup_connections() to close SQLite connections before deletion
- Delete the entire data directory using shutil.rmtree with custom onerror handler
- Also delete the log file (get_log_file()) if it exists
- Collect all failed paths in a list of (path, error_message) tuples
- Use best-effort deletion: continue on failure, report all failures at end
- Return the list of failures (empty list = complete success)
- NOTE: For Python 3.12+ compatibility, use onerror parameter (not onexc) since we support 3.10+

**get_binary_path() -> Path | None:**
- Return Path(sys.executable) if running frozen (getattr(sys, 'frozen', False))
- Return None if running in development mode
- Used by GUI to determine if binary cleanup is needed

**create_cleanup_script(binary_path: Path) -> tuple[str, str | None]:**
- Generate platform-specific script that deletes the binary after app exits
- Returns (message, script_path_or_none) tuple
- message: User-facing instruction string (e.g., "Data removed. Move app to Trash when ready.")
- script_path_or_none: Path to created script if applicable, None if manual instructions only

Platform behavior:
- **macOS:** If binary_path is inside a .app bundle, resolve to the .app directory. Create shell script at ~/.job-radar-cleanup.sh that sleeps 3 seconds then uses `osascript` to move to Trash via Finder. Execute with subprocess.Popen(start_new_session=True). Message: "Data removed. The app will be moved to Trash shortly."
- **Windows:** Create batch file at %USERPROFILE%\job-radar-cleanup.bat that waits 3 seconds then deletes the exe. Execute with subprocess.Popen using CREATE_NO_WINDOW flag. Message: "Data removed. The application will be deleted shortly."
- **Linux:** Create shell script at ~/.job-radar-cleanup.sh that sleeps 3 seconds then rm -f the binary, then self-deletes. Execute with subprocess.Popen(start_new_session=True). Message: "Data removed. The application will be deleted shortly."
- If script creation fails: return manual instruction message with the binary path, None for script path

Import from .paths: get_data_dir, get_log_file, is_frozen
Import from .rate_limits: _cleanup_connections
Standard lib: shutil, zipfile, sys, subprocess, pathlib.Path, logging, stat
  </action>
  <verify>
python -c "from job_radar.uninstaller import get_uninstall_paths, create_backup, delete_app_data, get_binary_path, create_cleanup_script; print('All imports OK')"
  </verify>
  <done>
Module exports 5 functions: get_uninstall_paths, create_backup, delete_app_data, get_binary_path, create_cleanup_script. All use paths.py for directory resolution. delete_app_data calls _cleanup_connections before shutil.rmtree.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive unit tests for uninstaller module</name>
  <files>tests/test_uninstaller.py</files>
  <action>
Create `tests/test_uninstaller.py` with the following test groups:

**get_uninstall_paths tests (3-4 tests):**
- Test returns paths with descriptions for existing files only
- Test returns empty list when data directory is empty
- Test includes log file when it exists
- Test descriptions are human-readable strings (not empty)
- Use tmp_path fixture, monkeypatch get_data_dir and get_log_file to point to tmp dirs

**create_backup tests (4-5 tests):**
- Test creates valid ZIP with profile.json and config.json
- Test ZIP contains correct file contents (read back and verify)
- Test skips missing files gracefully (only config.json exists -> ZIP has only config.json)
- Test raises on invalid save_path (e.g., directory that doesn't exist)
- Test empty data directory creates ZIP with no entries
- Monkeypatch get_data_dir to tmp_path

**delete_app_data tests (3-4 tests):**
- Test deletes entire data directory and returns empty failure list
- Test deletes log file when present
- Test returns failure list for locked/permission-denied files (mock shutil.rmtree to trigger onerror)
- Test calls _cleanup_connections before deletion (use mock to verify call order)
- Monkeypatch get_data_dir and get_log_file, mock _cleanup_connections

**get_binary_path tests (2 tests):**
- Test returns None when not frozen (normal dev mode)
- Test returns Path(sys.executable) when frozen (monkeypatch sys.frozen = True)

**create_cleanup_script tests (3-4 tests):**
- Test macOS: creates .sh script, returns appropriate message
- Test Windows: creates .bat script with correct content
- Test Linux: creates .sh script with execute permission
- Test returns manual instructions message when script creation fails
- Monkeypatch sys.platform and use tmp_path for script output

All tests use pytest fixtures (tmp_path, monkeypatch) and unittest.mock where needed. Follow existing test patterns in the codebase (e.g., test_profile_manager.py for file operation testing patterns).
  </action>
  <verify>
cd /Users/coryebert/Job-Radar && python -m pytest tests/test_uninstaller.py -v
  </verify>
  <done>
All tests pass. Test coverage includes: path enumeration with existing/missing files, backup creation with valid/missing files, deletion with success/failure cases, binary path detection for frozen/dev modes, cleanup script generation for all 3 platforms.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from job_radar.uninstaller import get_uninstall_paths, create_backup, delete_app_data, get_binary_path, create_cleanup_script"` succeeds
2. `python -m pytest tests/test_uninstaller.py -v` all tests pass
3. `python -m pytest tests/ -v` full suite passes with zero regressions
</verification>

<success_criteria>
- uninstaller.py exports 5 functions covering backup, deletion, path enumeration, binary detection, and cleanup scripts
- All functions handle cross-platform concerns via paths.py and sys.platform
- delete_app_data() calls _cleanup_connections() before deletion
- Best-effort deletion collects and returns failures instead of stopping
- 15+ unit tests cover happy paths, edge cases, and error scenarios
- Zero regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/36-gui-uninstall-feature/36-01-SUMMARY.md`
</output>
