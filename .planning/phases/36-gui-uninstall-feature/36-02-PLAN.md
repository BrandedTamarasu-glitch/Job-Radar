---
phase: 36-gui-uninstall-feature
plan: 02
type: execute
wave: 2
depends_on: ["36-01"]
files_modified:
  - job_radar/gui/uninstall_dialog.py
  - job_radar/gui/main_window.py
  - tests/test_uninstaller.py
autonomous: true

must_haves:
  truths:
    - "User can click Uninstall button in Settings tab to start the uninstall flow"
    - "User is offered backup option before seeing paths to be deleted"
    - "Confirmation dialog shows exact paths and requires checkbox before red Uninstall button activates"
    - "Progress dialog shows during deletion with indeterminate spinner"
    - "Success dialog shows completion message then app quits"
    - "Partial failures show list of paths that could not be deleted"
  artifacts:
    - path: "job_radar/gui/uninstall_dialog.py"
      provides: "BackupOfferDialog, PathPreviewDialog, FinalConfirmationDialog, DeletionProgressDialog"
      min_lines: 150
    - path: "job_radar/gui/main_window.py"
      provides: "Uninstall button in Settings tab, _start_uninstall() orchestration method"
      contains: "Uninstall Job Radar"
  key_links:
    - from: "job_radar/gui/uninstall_dialog.py"
      to: "job_radar/uninstaller.py"
      via: "create_backup, get_uninstall_paths, delete_app_data, get_binary_path, create_cleanup_script"
      pattern: "from job_radar.uninstaller import"
    - from: "job_radar/gui/main_window.py"
      to: "job_radar/gui/uninstall_dialog.py"
      via: "_start_uninstall() creates dialogs"
      pattern: "from job_radar.gui.uninstall_dialog import"
    - from: "job_radar/gui/main_window.py"
      to: "job_radar/uninstaller.py"
      via: "orchestration calls uninstaller functions"
      pattern: "from job_radar.uninstaller import"
---

<objective>
Create GUI uninstall dialogs and wire them into the Settings tab with full orchestration of the backup-preview-confirm-delete-quit flow.

Purpose: Deliver the user-facing uninstall experience with two-step confirmation, optional backup, progress feedback, and automatic quit. This completes the GUI uninstall feature (PKG-01, PKG-02, PKG-03, PKG-06).

Output: `job_radar/gui/uninstall_dialog.py` with dialog classes, updated `main_window.py` with uninstall button and orchestration, additional integration tests.
</objective>

<execution_context>
@/Users/coryebert/.claude/get-shit-done/workflows/execute-plan.md
@/Users/coryebert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/36-gui-uninstall-feature/36-CONTEXT.md
@.planning/phases/36-gui-uninstall-feature/36-RESEARCH.md
@.planning/phases/36-gui-uninstall-feature/36-01-SUMMARY.md
@job_radar/gui/main_window.py
@job_radar/uninstaller.py
@job_radar/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create uninstall_dialog.py with all dialog classes</name>
  <files>job_radar/gui/uninstall_dialog.py</files>
  <action>
Create `job_radar/gui/uninstall_dialog.py` with four dialog classes. All dialogs follow the existing modal pattern: CTkToplevel with transient(parent) + grab_set(), centered on parent.

**BackupOfferDialog(ctk.CTkToplevel):**
- Modal dialog offering backup before uninstall
- Title: "Uninstall Job Radar"
- Body text: "Would you like to create a backup of your profile and config before uninstalling?"
- Three buttons:
  - "Create Backup" (primary) -> opens native file picker via tkinter.filedialog.asksaveasfilename (defaultextension=".zip", initialfile="job-radar-backup.zip", filetypes=[("ZIP files", "*.zip")])
    - If user selects path: calls create_backup(save_path), sets self.result = "backup_done"
    - If create_backup raises: show error message in dialog, offer "Continue without backup" option
    - If user cancels file picker: return to this dialog (do nothing)
  - "Skip Backup" -> sets self.result = "skip"
  - "Cancel" -> sets self.result = "cancel"
- self.result attribute set before destroy(), parent reads it after wait_window()
- If backup succeeds, briefly show success text "Backup saved!" before proceeding

**PathPreviewDialog(ctk.CTkToplevel):**
- Modal dialog showing paths that will be deleted
- Title: "Files to be removed"
- Receives paths: list[tuple[str, str]] from get_uninstall_paths()
- Shows scrollable list of paths with descriptions in a CTkScrollableFrame
- Each entry: path in bold/monospace, description in gray below it
- "Continue" button and "Cancel" button at bottom
- self.result = True (continue) or False (cancel)

**FinalConfirmationDialog(ctk.CTkToplevel):**
- Modal dialog with checkbox + red button pattern (from CONTEXT.md decisions)
- Title: "Confirm Uninstall"
- Warning text: "This will permanently delete all Job Radar data. This action cannot be undone."
- CTkCheckBox: "I understand this cannot be undone" (variable: BooleanVar, default False)
- CTkButton "Uninstall" with fg_color="red", hover_color="darkred", initially state="disabled"
- Checkbox command toggles button state: checked -> "normal", unchecked -> "disabled"
- CTkButton "Cancel"
- self.result = True (confirmed) or False (cancelled)

**DeletionProgressDialog(ctk.CTkToplevel):**
- Modal dialog with indeterminate progress bar shown during deletion
- Title: "Uninstalling..."
- CTkLabel showing current status text (starts as "Deleting application data...")
- CTkProgressBar in mode="indeterminate", started
- Prevent window close: self.protocol("WM_DELETE_WINDOW", lambda: None)
- update_status(message: str) method to change label text
- close() method to stop progress bar and destroy

All dialogs:
- Use geometry sizing appropriate for content (~450x250 for simple, ~500x400 for path list)
- Center on parent window using the same pattern as _show_error_dialog in main_window.py
- Use self.wait_window() pattern so caller blocks until dialog closes and can read self.result
  </action>
  <verify>
python -c "from job_radar.gui.uninstall_dialog import BackupOfferDialog, PathPreviewDialog, FinalConfirmationDialog, DeletionProgressDialog; print('All dialog imports OK')"
  </verify>
  <done>
Four dialog classes exported: BackupOfferDialog (backup offer with file picker), PathPreviewDialog (path list with descriptions), FinalConfirmationDialog (checkbox + red button), DeletionProgressDialog (indeterminate progress). All follow existing modal dialog patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add uninstall button to Settings tab and wire orchestration flow</name>
  <files>job_radar/gui/main_window.py, tests/test_uninstaller.py</files>
  <action>
**main_window.py changes:**

1. Add import at top:
   ```python
   from job_radar.uninstaller import get_uninstall_paths, create_backup, delete_app_data, get_binary_path, create_cleanup_script
   ```

2. In _build_settings_tab(), AFTER the scoring config widget pack (after line ~938), add a separator and Uninstall section:
   - Separator (CTkFrame height=2, fg_color="gray70")
   - Section title: "Danger Zone" in red, bold, size 16
   - Description: "Remove Job Radar and all associated data from your system"
   - CTkButton "Uninstall Job Radar" with fg_color="red", hover_color="darkred", height=40, width=200
   - Button command: self._start_uninstall

3. Add _start_uninstall() method that orchestrates the full flow:
   ```
   Step 1: Show BackupOfferDialog
     - If result == "cancel": return (silent)
     - If result == "backup_done" or "skip": continue

   Step 2: Show PathPreviewDialog with get_uninstall_paths()
     - If result == False (cancel): return (silent)

   Step 3: Show FinalConfirmationDialog
     - If result == False (cancel): return (silent)

   Step 4: Show DeletionProgressDialog (non-blocking)
     - Run delete_app_data() in a background thread
     - On completion, update progress dialog

   Step 5: Handle results
     - If failures: show partial failure info with list of failed paths
     - Check get_binary_path():
       - If frozen: call create_cleanup_script(), show returned message
       - If not frozen: show "Data removed successfully" message
     - Show final success dialog: "Uninstall complete. Goodbye!"
     - After dialog dismissed: self.quit() to exit app
   ```

   Threading approach for Step 4: Use threading.Thread for delete_app_data(), then use self.after(0, callback) to update GUI from the thread result. The DeletionProgressDialog stays visible during deletion.

4. Import the dialog classes:
   ```python
   from job_radar.gui.uninstall_dialog import (
       BackupOfferDialog,
       PathPreviewDialog,
       FinalConfirmationDialog,
       DeletionProgressDialog,
   )
   ```

**tests/test_uninstaller.py additions (append to existing file from Plan 01):**

Add 3-4 integration-level tests:
- Test the full delete_app_data flow creates and removes a realistic data directory structure (profile.json, config.json, backups/, rate_limits.db)
- Test create_backup followed by delete_app_data preserves backup at external location
- Test get_uninstall_paths returns correct descriptions for standard file layout
- All use tmp_path with monkeypatched paths
  </action>
  <verify>
cd /Users/coryebert/Job-Radar && python -m pytest tests/test_uninstaller.py -v && python -m pytest tests/ -x -q
  </verify>
  <done>
Settings tab has red "Uninstall Job Radar" button in Danger Zone section. _start_uninstall() orchestrates: backup offer -> path preview -> final confirmation -> threaded deletion -> success/failure dialog -> app quit. Integration tests verify end-to-end data flow. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from job_radar.gui.uninstall_dialog import BackupOfferDialog, PathPreviewDialog, FinalConfirmationDialog, DeletionProgressDialog"` succeeds
2. `python -m pytest tests/test_uninstaller.py -v` all tests pass
3. `python -m pytest tests/ -x -q` full suite passes with zero regressions
4. Grep main_window.py for "Uninstall Job Radar" confirms button exists in Settings tab
5. Grep main_window.py for "_start_uninstall" confirms orchestration method exists
</verification>

<success_criteria>
- Settings tab shows "Danger Zone" section with red "Uninstall Job Radar" button
- Clicking button triggers backup offer -> path preview -> checkbox confirmation -> deletion -> quit flow
- Each step can be cancelled (silent return, no side effects)
- Backup creates ZIP via native file picker
- Deletion runs in background thread with progress dialog
- Partial failures reported with list of failed paths
- Binary cleanup script generated for frozen apps (macOS/Windows/Linux)
- App quits after successful uninstall
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/36-gui-uninstall-feature/36-02-SUMMARY.md`
</output>
