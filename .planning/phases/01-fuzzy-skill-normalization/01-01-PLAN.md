---
phase: 01-fuzzy-skill-normalization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: ["job_radar/scoring.py"]
autonomous: true

must_haves:
  truths:
    - "A skill listed as 'NodeJS' in the profile matches 'node.js' in job text"
    - "A skill listed as 'node.js' in the profile matches 'NodeJS' in job text"
    - "'go' does not match inside 'going', 'algorithm', or 'google'"
    - "'r' does not match inside 'programming' or 'server'"
    - "'c' does not match inside 'specific' or 'architecture'"
    - "All existing _SKILL_VARIANTS entries still resolve correctly"
    - "'kubernetes' matches 'k8s' and vice versa"
    - "'python' matches 'python3'"
  artifacts:
    - path: "job_radar/scoring.py"
      provides: "_normalize_skill() function, _SKILL_VARIANTS_NORMALIZED dict, updated _skill_in_text(), expanded _SKILL_VARIANTS"
      contains: "_normalize_skill"
  key_links:
    - from: "_skill_in_text()"
      to: "_SKILL_VARIANTS_NORMALIZED"
      via: "_normalize_skill() applied to lookup key"
      pattern: "_SKILL_VARIANTS_NORMALIZED\\.get\\(_normalize_skill"
    - from: "_SKILL_VARIANTS_NORMALIZED"
      to: "_SKILL_VARIANTS"
      via: "dict comprehension with _normalize_skill on keys"
      pattern: "_normalize_skill\\(k\\).*for k, v in _SKILL_VARIANTS"
    - from: "_build_skill_pattern()"
      to: "_BOUNDARY_SKILLS"
      via: "membership check unchanged"
      pattern: "skill\\.lower\\(\\) in _BOUNDARY_SKILLS"
---

<objective>
Add fuzzy skill normalization to scoring.py so that punctuation and casing variants of technology names match correctly during skill scoring.

Purpose: The current `_skill_in_text()` function fails to match "NodeJS" against "node.js" because `"nodejs" != "node.js"` as a dict key. This causes incorrect skill match scores, which undermines the core value of the entire tool.

Output: Updated `job_radar/scoring.py` with `_normalize_skill()`, normalized variant lookup, preserved boundary-skill protection, and expanded `_SKILL_VARIANTS` dict.
</objective>

<execution_context>
@/Users/coryebert/.claude/get-shit-done/workflows/execute-plan.md
@/Users/coryebert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-fuzzy-skill-normalization/01-RESEARCH.md
@job_radar/scoring.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _normalize_skill() and wire normalized variant lookup into _skill_in_text()</name>
  <files>job_radar/scoring.py</files>
  <action>
    Make the following changes to `job_radar/scoring.py`, all within the skill matching section (around lines 166-224):

    1. Add a compiled regex constant and `_normalize_skill()` function ABOVE `_SKILL_VARIANTS`:

    ```python
    _NORM_RE = re.compile(r'[\.\-\s]+')

    def _normalize_skill(s: str) -> str:
        """Strip separator punctuation (dots, hyphens, spaces), lowercase.

        Preserves meaningful punctuation: # in C#, + in C++.

        Examples:
            "Node.js"   -> "nodejs"
            "node js"   -> "nodejs"
            ".NET"      -> "net"
            "C#"        -> "c#"
            "C++"       -> "c++"
        """
        return _NORM_RE.sub('', s.lower())
    ```

    2. Add `_SKILL_VARIANTS_NORMALIZED` IMMEDIATELY AFTER the `_SKILL_VARIANTS` dict (after line 195):

    ```python
    _SKILL_VARIANTS_NORMALIZED: dict[str, list[str]] = {
        _normalize_skill(k): v for k, v in _SKILL_VARIANTS.items()
    }
    ```

    3. Update `_skill_in_text()` to use normalized lookup. Replace the existing variant lookup line:
       - OLD: `variants = _SKILL_VARIANTS.get(skill.lower(), [])`
       - NEW: `variants = _SKILL_VARIANTS_NORMALIZED.get(_normalize_skill(skill), [])`

    Do NOT change `_build_skill_pattern()` at all -- it must remain exactly as-is. The boundary-skill protection (`_BOUNDARY_SKILLS` set and `len(skill) <= 2` check) is correct and must not be modified.

    Do NOT normalize the `text` parameter in `_skill_in_text()`. Only the lookup key is normalized. The variant values remain in their original form so that `_build_skill_pattern()` can build correct regex patterns.

    Do NOT normalize the variant list values in `_SKILL_VARIANTS`. Only the keys are normalized via `_SKILL_VARIANTS_NORMALIZED`.
  </action>
  <verify>
    Run these checks in a Python REPL from the project root:

    ```bash
    cd "/Users/coryebert/Documents/Job Hunt Python/Project Folder/Job-Radar"
    python3 -c "
    from job_radar.scoring import _normalize_skill, _skill_in_text, _SKILL_VARIANTS_NORMALIZED, _BOUNDARY_SKILLS

    # FUZZ-01: _normalize_skill works correctly
    assert _normalize_skill('Node.js') == 'nodejs', f'Got: {_normalize_skill(\"Node.js\")}'
    assert _normalize_skill('NodeJS') == 'nodejs'
    assert _normalize_skill('.NET') == 'net'
    assert _normalize_skill('C#') == 'c#'
    assert _normalize_skill('C++') == 'c++'
    assert _normalize_skill('node js') == 'nodejs'
    assert _normalize_skill('node-js') == 'nodejs'
    print('PASS: _normalize_skill')

    # FUZZ-02: Normalized lookup works
    assert _skill_in_text('NodeJS', 'we use node.js and react'), 'NodeJS should match node.js in text'
    assert _skill_in_text('node.js', 'we use nodejs and react'), 'node.js should match nodejs in text'
    assert _skill_in_text('React', 'we use reactjs'), 'React should match reactjs'
    print('PASS: normalized lookup')

    # FUZZ-03: Boundary skills still protected
    assert not _skill_in_text('go', 'we are going to the store'), 'go must not match going'
    assert not _skill_in_text('r', 'programming is fun'), 'r must not match programming'
    assert not _skill_in_text('c', 'specific architecture'), 'c must not match specific'
    assert _skill_in_text('go', 'experience with go and python'), 'go should match standalone go'
    print('PASS: boundary skills protected')

    # FUZZ-04: Existing variants still work
    assert _skill_in_text('c#', 'csharp developer'), 'c# should match csharp'
    assert _skill_in_text('.net', 'dotnet framework'), '.net should match dotnet'
    assert _skill_in_text('postgresql', 'postgres database'), 'postgresql should match postgres'
    assert _skill_in_text('rpa', 'robotic process automation'), 'rpa should match variant'
    assert _skill_in_text('uipath', 'ui path developer'), 'uipath should match ui path'
    print('PASS: existing variants work')

    # Key collision check
    keys = list(_SKILL_VARIANTS_NORMALIZED.keys())
    assert len(keys) == len(set(keys)), f'Key collision detected in normalized variants'
    print('PASS: no key collisions')

    print('ALL CHECKS PASSED')
    "
    ```
  </verify>
  <done>
    - `_normalize_skill()` exists and strips dots, hyphens, spaces while preserving # and +
    - `_SKILL_VARIANTS_NORMALIZED` is built at module level from `_SKILL_VARIANTS`
    - `_skill_in_text()` uses normalized key for variant lookup
    - `_build_skill_pattern()` is unchanged
    - `_BOUNDARY_SKILLS` protection is preserved -- short skills still use word-boundary matching
    - Zero regressions on existing `_SKILL_VARIANTS` entries
  </done>
</task>

<task type="auto">
  <name>Task 2: Expand _SKILL_VARIANTS with missing common tech variants</name>
  <files>job_radar/scoring.py</files>
  <action>
    Add the following entries to the `_SKILL_VARIANTS` dict in `job_radar/scoring.py`. Add them AFTER the existing entries (before the closing brace) to keep the diff clean. These are semantic aliases that normalization alone cannot bridge:

    ```python
    "python": ["python", "python3", "py3"],
    "go": ["go", "golang"],
    "vue": ["vue", "vue.js", "vuejs"],
    "angular": ["angular", "angular.js", "angularjs"],
    "kubernetes": ["kubernetes", "k8s"],
    "aws": ["aws", "amazon web services"],
    "gcp": ["gcp", "google cloud", "google cloud platform"],
    "azure": ["azure", "microsoft azure"],
    "docker": ["docker", "containerization"],
    "terraform": ["terraform", "tf"],
    "sql": ["sql", "structured query language"],
    "nosql": ["nosql", "no-sql"],
    "rest": ["rest", "restful", "rest api", "restful api"],
    "graphql": ["graphql", "graph ql"],
    "ci/cd": ["ci/cd", "ci cd", "cicd", "continuous integration", "continuous deployment"],
    ```

    IMPORTANT: After adding these entries, `_SKILL_VARIANTS_NORMALIZED` is built via dict comprehension from `_SKILL_VARIANTS`, so it will automatically pick up all new entries. No additional wiring is needed.

    Verify there are no duplicate normalized keys after expansion. If `"go"` is added as a key and `"go"` normalizes to `"go"`, ensure it does not collide with any existing key. (It will not -- there is no existing `"go"` key in `_SKILL_VARIANTS`.)

    Note on `"go"` specifically: `"go"` is in `_BOUNDARY_SKILLS`, so it already uses word-boundary matching for direct pattern matches. Adding it to `_SKILL_VARIANTS` enables `"golang"` as a variant that maps back to `"go"`. The variant `"golang"` is long enough to NOT need boundary matching, which is correct behavior.

    Note on `"sql"`: This is a 3-character skill, so it will NOT trigger the `len(skill) <= 2` boundary guard. It will get a plain substring match. This is acceptable because "sql" rarely appears as a substring of unrelated words. If false positives emerge later, it can be added to `_BOUNDARY_SKILLS`.
  </action>
  <verify>
    Run these checks from the project root:

    ```bash
    cd "/Users/coryebert/Documents/Job Hunt Python/Project Folder/Job-Radar"
    python3 -c "
    from job_radar.scoring import _skill_in_text, _SKILL_VARIANTS_NORMALIZED

    # FUZZ-05: New variants work
    assert _skill_in_text('kubernetes', 'experience with k8s clusters'), 'kubernetes should match k8s'
    assert _skill_in_text('k8s', 'kubernetes orchestration'), 'k8s should match kubernetes (via direct pattern)'
    assert _skill_in_text('python', 'python3 scripting'), 'python should match python3'
    assert _skill_in_text('go', 'experience with golang'), 'go should match golang'
    assert _skill_in_text('vue', 'vue.js frontend'), 'vue should match vue.js'
    assert _skill_in_text('aws', 'amazon web services certified'), 'aws should match amazon web services'
    assert _skill_in_text('docker', 'containerization experience'), 'docker should match containerization'
    assert _skill_in_text('rest', 'restful api design'), 'rest should match restful'
    assert _skill_in_text('graphql', 'graph ql endpoint'), 'graphql should match graph ql'
    assert _skill_in_text('ci/cd', 'continuous integration pipeline'), 'ci/cd should match continuous integration'
    assert _skill_in_text('terraform', 'infrastructure with tf'), 'terraform should match tf'
    assert _skill_in_text('gcp', 'google cloud platform'), 'gcp should match google cloud platform'
    assert _skill_in_text('azure', 'microsoft azure services'), 'azure should match microsoft azure'
    assert _skill_in_text('angular', 'angularjs application'), 'angular should match angularjs'
    assert _skill_in_text('nosql', 'no-sql database'), 'nosql should match no-sql'
    print('PASS: all new variants work')

    # Boundary skill protection still holds after expansion
    assert not _skill_in_text('go', 'algorithm development'), 'go must not match algorithm'
    assert _skill_in_text('go', 'proficient in go and rust'), 'go should match standalone go'
    print('PASS: boundary protection preserved')

    # Existing variants unbroken
    assert _skill_in_text('node.js', 'nodejs developer'), 'existing node.js variant still works'
    assert _skill_in_text('c#', 'c sharp developer'), 'existing c# variant still works'
    assert _skill_in_text('react', 'react.js frontend'), 'existing react variant still works'
    print('PASS: existing variants unbroken')

    # No key collisions in normalized dict
    from job_radar.scoring import _SKILL_VARIANTS, _normalize_skill
    normalized_keys = [_normalize_skill(k) for k in _SKILL_VARIANTS.keys()]
    dupes = [k for k in normalized_keys if normalized_keys.count(k) > 1]
    assert not dupes, f'Key collision after expansion: {set(dupes)}'
    print('PASS: no key collisions')

    print('ALL CHECKS PASSED')
    "
    ```
  </verify>
  <done>
    - 15 new tech variant entries added to `_SKILL_VARIANTS`
    - All new variants resolve correctly via `_skill_in_text()`
    - No key collisions in `_SKILL_VARIANTS_NORMALIZED` after expansion
    - Boundary skill protection still works for "go", "r", "c"
    - Zero regressions on previously existing variant entries
  </done>
</task>

</tasks>

<verification>
Run the complete verification suite from the project root:

```bash
cd "/Users/coryebert/Documents/Job Hunt Python/Project Folder/Job-Radar"
python3 -c "
from job_radar.scoring import (
    _normalize_skill, _skill_in_text,
    _SKILL_VARIANTS, _SKILL_VARIANTS_NORMALIZED, _BOUNDARY_SKILLS
)

passed = 0
failed = 0

def check(condition, label):
    global passed, failed
    if condition:
        passed += 1
    else:
        failed += 1
        print(f'FAIL: {label}')

# === FUZZ-01: Normalization function ===
check(_normalize_skill('Node.js') == 'nodejs', 'normalize Node.js')
check(_normalize_skill('NodeJS') == 'nodejs', 'normalize NodeJS')
check(_normalize_skill('.NET') == 'net', 'normalize .NET')
check(_normalize_skill('C#') == 'c#', 'normalize C# preserves #')
check(_normalize_skill('C++') == 'c++', 'normalize C++ preserves +')
check(_normalize_skill('node js') == 'nodejs', 'normalize node js')
check(_normalize_skill('node-js') == 'nodejs', 'normalize node-js')
check(_normalize_skill('React.js') == 'reactjs', 'normalize React.js')

# === FUZZ-02: Cross-format matching ===
check(_skill_in_text('NodeJS', 'we use node.js daily'), 'NodeJS matches node.js text')
check(_skill_in_text('node.js', 'we use nodejs daily'), 'node.js matches nodejs text')
check(_skill_in_text('React', 'reactjs framework'), 'React matches reactjs')
check(_skill_in_text('.NET', 'dotnet developer'), '.NET matches dotnet')

# === FUZZ-03: Boundary skills ===
check(not _skill_in_text('go', 'going to the store'), 'go does not match going')
check(not _skill_in_text('go', 'algorithm design'), 'go does not match algorithm')
check(not _skill_in_text('r', 'programming language'), 'r does not match programming')
check(not _skill_in_text('c', 'specific task'), 'c does not match specific')
check(_skill_in_text('go', 'experience in go and python'), 'go matches standalone go')
check(_skill_in_text('r', 'experience in r and python'), 'r matches standalone r')

# === FUZZ-04: Existing variants ===
check(_skill_in_text('c#', 'csharp developer'), 'c# -> csharp')
check(_skill_in_text('postgresql', 'postgres db'), 'postgresql -> postgres')
check(_skill_in_text('rpa', 'robotic process automation'), 'rpa -> robotic process automation')
check(_skill_in_text('uipath', 'ui path developer'), 'uipath -> ui path')
check(_skill_in_text('blue prism', 'blueprism tool'), 'blue prism -> blueprism')
check(_skill_in_text('safe', 'scaled agile framework'), 'safe -> scaled agile')
check(_skill_in_text('business analysis', 'business analyst role'), 'business analysis -> business analyst')

# === FUZZ-05: New variants ===
check(_skill_in_text('kubernetes', 'k8s cluster'), 'kubernetes -> k8s')
check(_skill_in_text('python', 'python3 scripting'), 'python -> python3')
check(_skill_in_text('go', 'golang services'), 'go -> golang')
check(_skill_in_text('vue', 'vue.js frontend'), 'vue -> vue.js')
check(_skill_in_text('aws', 'amazon web services'), 'aws -> amazon web services')
check(_skill_in_text('docker', 'containerization'), 'docker -> containerization')
check(_skill_in_text('rest', 'restful api'), 'rest -> restful')
check(_skill_in_text('graphql', 'graph ql endpoint'), 'graphql -> graph ql')
check(_skill_in_text('ci/cd', 'continuous integration'), 'ci/cd -> continuous integration')
check(_skill_in_text('terraform', 'infrastructure with tf'), 'terraform -> tf')
check(_skill_in_text('gcp', 'google cloud platform'), 'gcp -> google cloud platform')
check(_skill_in_text('azure', 'microsoft azure'), 'azure -> microsoft azure')

# === No key collisions ===
normalized_keys = [_normalize_skill(k) for k in _SKILL_VARIANTS.keys()]
dupes = set(k for k in normalized_keys if normalized_keys.count(k) > 1)
check(not dupes, f'no key collisions (dupes: {dupes})')

print(f'\nResults: {passed} passed, {failed} failed out of {passed + failed} checks')
if failed == 0:
    print('ALL CHECKS PASSED')
else:
    print('SOME CHECKS FAILED')
    exit(1)
"
```

Also verify the module imports cleanly with no errors:

```bash
python3 -c "import job_radar.scoring; print('Module imports OK')"
```
</verification>

<success_criteria>
1. `_normalize_skill("NodeJS") == "nodejs"` and `_normalize_skill("node.js") == "nodejs"` -- same normalized form
2. `_normalize_skill("C#") == "c#"` -- meaningful punctuation preserved
3. `_skill_in_text("NodeJS", "node.js developer")` returns True
4. `_skill_in_text("go", "going nowhere")` returns False -- boundary protection intact
5. All 21+ existing `_SKILL_VARIANTS` entries continue to match their variants
6. 15 new tech variant entries added and functional
7. No key collisions in `_SKILL_VARIANTS_NORMALIZED`
8. Module imports with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-fuzzy-skill-normalization/01-01-SUMMARY.md`
</output>
