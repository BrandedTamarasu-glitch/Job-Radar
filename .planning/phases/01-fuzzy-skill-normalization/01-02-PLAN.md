---
phase: 01-fuzzy-skill-normalization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified: ["job_radar/scoring.py"]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "All existing _SKILL_VARIANTS entries still resolve correctly"
    - "_skill_in_text('c#', 'Senior C# Developer') returns True"
    - "_skill_in_text('c++', 'C++ systems programmer') returns True (if c++ is affected)"
    - "_BOUNDARY_SKILLS protection for 'c', 'r', 'go' still works after fix"
---

<objective>
Fix the C# (and C++) direct-match regression in _build_skill_pattern().

The len(skill) <= 2 word-boundary guard incorrectly triggers for "c#" (length 2),
generating \bc\#\b. Because # is a non-word character, the \b after c always
fails when followed by #. Job postings that use the standard "C#" notation are
silently unmatched.

The fix: add a check so that skills whose length <= 2 only get boundary treatment
if they consist entirely of word characters. Skills with non-word chars like # or +
are already unambiguous and don't need boundaries.
</objective>

<tasks>

<task type="auto">
  <name>Fix _build_skill_pattern() boundary guard for skills with non-word characters</name>
  <files>job_radar/scoring.py</files>
  <action>
    In `job_radar/scoring.py`, update `_build_skill_pattern()` at line 240-245.

    Current code:
    ```python
    def _build_skill_pattern(skill: str) -> re.Pattern:
        """Build a regex pattern for a skill, using word boundaries for short/ambiguous terms."""
        escaped = re.escape(skill.lower())
        if skill.lower() in _BOUNDARY_SKILLS or len(skill) <= 2:
            return re.compile(rf'\b{escaped}\b', re.IGNORECASE)
        return re.compile(re.escape(skill.lower()), re.IGNORECASE)
    ```

    Replace with:
    ```python
    _WORD_ONLY_RE = re.compile(r'^\w+$')


    def _build_skill_pattern(skill: str) -> re.Pattern:
        """Build a regex pattern for a skill, using word boundaries for short/ambiguous terms.

        Word boundaries are applied only when the skill is short (<=2 chars) AND
        consists entirely of word characters. Skills containing non-word characters
        like # (C#) or + (C++) are unambiguous and don't need boundary protection.
        """
        escaped = re.escape(skill.lower())
        needs_boundary = (
            skill.lower() in _BOUNDARY_SKILLS
            or (len(skill) <= 2 and bool(_WORD_ONLY_RE.match(skill)))
        )
        if needs_boundary:
            return re.compile(rf'\b{escaped}\b', re.IGNORECASE)
        return re.compile(re.escape(skill.lower()), re.IGNORECASE)
    ```

    Place `_WORD_ONLY_RE` as a module-level constant just above `_build_skill_pattern()`.

    This change:
    - Preserves boundary matching for "c", "r", "go", "ai", "ml" etc. (pure word chars <= 2)
    - Removes boundary matching from "c#" (length 2 but contains #)
    - Removes boundary matching from "c++" (length 3, not affected by len <= 2, but documenting)
    - Does not change any other behavior
  </action>
  <verify>
    ```bash
    cd "/Users/coryebert/Documents/Job Hunt Python/Project Folder/Job-Radar"
    python3 -c "
    from job_radar.scoring import _skill_in_text, _build_skill_pattern, _BOUNDARY_SKILLS

    # The gap: c# must match literal C# in job text
    assert _skill_in_text('c#', 'Senior C# Developer'), 'c# must match C# in job text'
    assert _skill_in_text('c#', 'Required: C#, .NET, SQL'), 'c# must match C# in skill list'
    assert _skill_in_text('C#', 'c# programming'), 'C# must match c# in text'
    print('PASS: c# direct match works')

    # Existing variant path still works
    assert _skill_in_text('c#', 'csharp developer'), 'c# -> csharp variant still works'
    assert _skill_in_text('c#', 'c sharp programming'), 'c# -> c sharp variant still works'
    print('PASS: c# variants still work')

    # Boundary protection for pure word-char skills unchanged
    assert not _skill_in_text('c', 'specific architecture'), 'c still has boundary protection'
    assert not _skill_in_text('r', 'programming language'), 'r still has boundary protection'
    assert not _skill_in_text('go', 'going to work'), 'go still has boundary protection'
    assert _skill_in_text('c', 'experience with c and assembly'), 'c still matches standalone c'
    print('PASS: boundary skills still protected')

    # Verify pattern for c# doesn't use word boundaries
    pattern = _build_skill_pattern('c#')
    assert pattern.search('C# Developer'), 'c# pattern matches C# Developer'
    print('PASS: _build_skill_pattern fix verified')

    print('ALL CHECKS PASSED')
    "
    ```
  </verify>
  <done>
    - _build_skill_pattern() checks for non-word characters before applying len<=2 boundary rule
    - c# matches literal 'C#' and 'c#' in job text (direct pattern)
    - c# variants (csharp, c sharp) still work via _SKILL_VARIANTS lookup
    - Boundary protection for c, r, go, ai, ml, qa, pm, ci, cd, ts, js unchanged
    - _WORD_ONLY_RE compiled constant added above _build_skill_pattern()
  </done>
</task>

</tasks>

<verification>
```bash
cd "/Users/coryebert/Documents/Job Hunt Python/Project Folder/Job-Radar"
python3 -c "
from job_radar.scoring import _skill_in_text, _SKILL_VARIANTS, _normalize_skill

passed = 0
failed = 0

def check(condition, label):
    global passed, failed
    if condition:
        passed += 1
    else:
        failed += 1
        print(f'FAIL: {label}')

# Gap fix
check(_skill_in_text('c#', 'Senior C# Developer'), 'c# matches C# in job text')
check(_skill_in_text('c#', 'skills: C#, .NET, SQL'), 'c# matches C# in skills list')
check(_skill_in_text('C#', 'c# engineer'), 'C# matches c# (case insensitive)')

# Variants still work
check(_skill_in_text('c#', 'csharp developer'), 'c# variant: csharp')
check(_skill_in_text('c#', 'c sharp programmer'), 'c# variant: c sharp')

# Boundary protection unchanged
check(not _skill_in_text('c', 'specific'), 'c boundary: not specific')
check(not _skill_in_text('r', 'programming'), 'r boundary: not programming')
check(not _skill_in_text('go', 'going'), 'go boundary: not going')
check(_skill_in_text('c', 'strong c skills'), 'c still matches standalone')
check(_skill_in_text('go', 'knows go and rust'), 'go still matches standalone')

# All original FUZZ-04 variants
check(_skill_in_text('postgresql', 'postgres db'), 'postgresql -> postgres')
check(_skill_in_text('rpa', 'robotic process automation'), 'rpa -> rpa variant')
check(_skill_in_text('uipath', 'ui path developer'), 'uipath -> ui path')
check(_skill_in_text('.net', 'dotnet framework'), '.net -> dotnet')
check(_skill_in_text('node.js', 'nodejs developer'), 'node.js -> nodejs')

print(f'Results: {passed} passed, {failed} failed')
if failed == 0:
    print('ALL CHECKS PASSED')
else:
    exit(1)
"
```
</verification>

<success_criteria>
1. _skill_in_text('c#', 'Senior C# Developer') returns True
2. _build_skill_pattern('c#') generates a pattern that matches 'C# Developer'
3. All _BOUNDARY_SKILLS still have word-boundary protection
4. All existing _SKILL_VARIANTS entries resolve correctly
</success_criteria>
