---
phase: 06-core-packaging-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - job-radar.spec
  - scripts/build.sh
  - scripts/build.bat
  - dist/README.txt
  - job_radar/__main__.py
autonomous: true

must_haves:
  truths:
    - "PyInstaller builds successfully from .spec file on current platform"
    - "Built executable launches and displays banner without Python installed (verified on macOS)"
    - "Built executable can find bundled profile template via sys._MEIPASS path"
    - "All dependencies (requests, bs4, platformdirs, pyfiglet, colorama, certifi) are bundled"
    - "Hidden imports declared for questionary, prompt_toolkit, platformdirs, certifi"
    - "Build uses onedir mode with console=True and UPX disabled"
  artifacts:
    - path: "job-radar.spec"
      provides: "PyInstaller build specification"
      contains: "hiddenimports"
    - path: "scripts/build.sh"
      provides: "Cross-platform build and distribution script (macOS/Linux)"
    - path: "scripts/build.bat"
      provides: "Windows build script"
    - path: "dist/README.txt"
      provides: "End-user installation and troubleshooting guide"
    - path: "job_radar/__main__.py"
      provides: "Updated entry point with banner, error handling, and SSL cert fix"
  key_links:
    - from: "job-radar.spec"
      to: "job_radar/__main__.py"
      via: "Analysis scripts parameter"
      pattern: "job_radar/__main__\\.py"
    - from: "job-radar.spec"
      to: "profiles/_template.json"
      via: "datas parameter bundling"
      pattern: "datas.*_template"
    - from: "job_radar/__main__.py"
      to: "job_radar/banner.py"
      via: "display_banner() import"
      pattern: "from.*banner.*import.*display_banner"
    - from: "job_radar/__main__.py"
      to: "certifi"
      via: "REQUESTS_CA_BUNDLE env var for frozen SSL"
      pattern: "REQUESTS_CA_BUNDLE"
---

<objective>
Create the PyInstaller .spec file, build scripts, updated entry point, and end-user README to produce working standalone executables.

Purpose: This is the core deliverable of Phase 6 - turning Job Radar from a Python package into double-click executables. The .spec file defines what gets bundled, the entry point adds startup infrastructure (banner, error logging, SSL fix), and the build scripts automate the packaging process.

Output: Working PyInstaller build that produces a `dist/job-radar/` folder (onedir) containing the executable and all dependencies. Build scripts for all three platforms. README.txt for end users.
</objective>

<execution_context>
@/Users/coryebert/.claude/get-shit-done/workflows/execute-plan.md
@/Users/coryebert/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-core-packaging-infrastructure/06-RESEARCH.md
@.planning/phases/06-core-packaging-infrastructure/06-01-SUMMARY.md
@job_radar/__main__.py
@job_radar/search.py
@job_radar/paths.py
@job_radar/banner.py
@profiles/_template.json
@pyproject.toml
@.gitignore
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update entry point and create .spec file</name>
  <files>
    job_radar/__main__.py
    job-radar.spec
  </files>
  <action>
1. Rewrite `job_radar/__main__.py` to add startup infrastructure:

```python
"""Allow running as ``python -m job_radar`` and as PyInstaller entry point."""

import os
import sys


def _fix_ssl_for_frozen():
    """Set REQUESTS_CA_BUNDLE for frozen builds so HTTPS works."""
    if getattr(sys, 'frozen', False):
        try:
            import certifi
            os.environ['REQUESTS_CA_BUNDLE'] = certifi.where()
        except ImportError:
            pass  # certifi missing - requests will use system certs


def main():
    _fix_ssl_for_frozen()

    try:
        from job_radar.banner import display_banner
        from job_radar import __version__
        display_banner(version=__version__)
    except Exception:
        # Banner is non-critical, continue even if it fails
        pass

    try:
        from job_radar.search import main as search_main
        search_main()
    except KeyboardInterrupt:
        print("\nInterrupted by user.")
        sys.exit(0)
    except Exception as e:
        try:
            from job_radar.banner import log_error_and_exit
            log_error_and_exit(f"Fatal error: {e}", exception=e)
        except Exception:
            # Last resort if even error logging fails
            print(f"\nFatal error: {e}")
            sys.exit(1)


if __name__ == '__main__':
    main()
```

Key design decisions:
- SSL fix runs BEFORE any imports that use requests (critical for frozen HTTPS)
- Banner displays before search starts (locked decision: show banner on launch)
- KeyboardInterrupt caught to exit cleanly without traceback
- Fatal errors logged to ~/job-radar-error.log via log_error_and_exit()
- Backward compatible: `python -m job_radar` still works

2. Create `job-radar.spec` in project root:

```python
# -*- mode: python ; coding: utf-8 -*-
"""PyInstaller spec file for Job Radar.

Build with: pyinstaller job-radar.spec --clean
Output: dist/job-radar/ (onedir bundle)
"""

import sys
from pathlib import Path

project_root = Path('.').resolve()

# Data files to bundle (source_path, dest_folder_in_bundle)
# Profile template so users have a starting point
added_files = [
    (str(project_root / 'profiles' / '_template.json'), 'profiles'),
]

# Hidden imports: modules that PyInstaller's static analysis misses
# because they are imported dynamically at runtime
hidden_imports = [
    # Direct dependencies
    'requests',
    'bs4',
    'html.parser',          # bs4 parser (used in sources.py)
    'platformdirs',
    'pyfiglet',
    'colorama',
    'certifi',
    # Transitive dependencies
    'prompt_toolkit',       # questionary dependency (Phase 7)
    'questionary',          # Setup wizard (Phase 7, declare now to avoid rebuild)
    'charset_normalizer',   # requests dependency
    'idna',                 # requests dependency
    'urllib3',              # requests dependency
    'soupsieve',            # bs4 dependency
]

a = Analysis(
    [str(project_root / 'job_radar' / '__main__.py')],
    pathex=[str(project_root)],
    binaries=[],
    datas=added_files,
    hiddenimports=hidden_imports,
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[
        'tkinter',
        'matplotlib',
        'numpy',
        'scipy',
        'pandas',
        'PIL',
        'cv2',
        'torch',
        'tensorflow',
    ],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=None,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=None)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,     # True = onedir mode (PKG-04)
    name='job-radar',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=False,                 # Disabled: reduces antivirus false positives
    console=True,              # Locked decision: show console window
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=False,
    upx_exclude=[],
    name='job-radar',
)

# macOS app bundle (only when building on macOS)
if sys.platform == 'darwin':
    app = BUNDLE(
        coll,
        name='JobRadar.app',
        icon=None,
        bundle_identifier='com.jobradar.app',
        info_plist={
            'NSHighResolutionCapable': 'True',
            'LSBackgroundOnly': 'False',    # Locked decision: show in dock
        },
    )
```

Important .spec decisions:
- Entry point is `job_radar/__main__.py` (not search.py) so banner/SSL fix run first
- onedir mode (exclude_binaries=True in EXE + COLLECT) for fast startup (PKG-04)
- UPX disabled to avoid antivirus false positives (research recommendation)
- console=True (locked decision: show console for transparency)
- Hidden imports include ALL known transitive deps plus questionary/prompt_toolkit pre-declared for Phase 7
- Excludes heavy unused packages (tkinter, matplotlib, numpy, etc.)
- macOS BUNDLE only runs on darwin (conditional)
- LSBackgroundOnly=False (locked decision: show in dock on macOS)
- profiles/_template.json bundled so frozen app has a template for new users
  </action>
  <verify>
    Verify .spec file syntax: `python -c "exec(open('job-radar.spec').read())"` should NOT be run (spec files use PyInstaller globals). Instead verify by running `pyinstaller job-radar.spec --clean` and checking it starts without syntax errors.
    Verify entry point: `python -c "from job_radar.__main__ import main"` imports without error.
  </verify>
  <done>
    __main__.py has SSL fix, banner display, error handling, and KeyboardInterrupt catch.
    job-radar.spec defines onedir build with console=True, UPX disabled, all hidden imports declared, profile template bundled.
    macOS .app bundle configured with dock visibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create build scripts, README.txt, and run first build</name>
  <files>
    scripts/build.sh
    scripts/build.bat
    dist/README.txt
  </files>
  <action>
1. Create `scripts/` directory.

2. Create `scripts/build.sh` (macOS/Linux build + distribution packaging):

```bash
#!/bin/bash
# Build Job Radar standalone executable and create distribution archive.
# Usage: ./scripts/build.sh
# Output: dist/job-radar/ (executable bundle) + platform-specific archive

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
cd "$PROJECT_ROOT"

VERSION="1.1.0"

echo "=== Job Radar Build Script ==="
echo "Version: $VERSION"
echo "Platform: $(uname -s) $(uname -m)"
echo ""

# Step 1: Clean previous builds
echo "Step 1: Cleaning previous builds..."
rm -rf build/ dist/

# Step 2: Install PyInstaller if needed
if ! pip show pyinstaller > /dev/null 2>&1; then
    echo "Installing PyInstaller..."
    pip install pyinstaller
fi

# Step 3: Build
echo "Step 2: Building with PyInstaller..."
pyinstaller job-radar.spec --clean

# Step 4: Copy README into dist folder
echo "Step 3: Adding README..."
cp dist/README.txt dist/job-radar/README.txt 2>/dev/null || true

# Step 5: Platform-specific distribution packaging
echo "Step 4: Creating distribution archive..."

if [[ "$(uname -s)" == "Darwin" ]]; then
    # macOS: Create ZIP of .app bundle (DMG requires create-dmg tool)
    echo "  Packaging macOS .app as ZIP..."
    cd dist
    zip -r "JobRadar-${VERSION}-macos.zip" JobRadar.app/ job-radar/README.txt 2>/dev/null || \
    zip -r "JobRadar-${VERSION}-macos.zip" job-radar/
    cd ..
    echo "  Archive: dist/JobRadar-${VERSION}-macos.zip"
else
    # Linux: Create tar.gz
    echo "  Packaging Linux binary as tar.gz..."
    cd dist
    tar -czf "job-radar-${VERSION}-linux.tar.gz" job-radar/
    cd ..
    echo "  Archive: dist/job-radar-${VERSION}-linux.tar.gz"
fi

echo ""
echo "=== Build Complete ==="
echo "Executable: dist/job-radar/job-radar"
echo ""
echo "Quick test: ./dist/job-radar/job-radar --help"
```

Make it executable: `chmod +x scripts/build.sh`

3. Create `scripts/build.bat` (Windows build script):

```batch
@echo off
REM Build Job Radar standalone executable for Windows.
REM Usage: scripts\build.bat
REM Output: dist\job-radar\ (executable bundle) + ZIP archive

setlocal
set VERSION=1.1.0

echo === Job Radar Build Script ===
echo Version: %VERSION%
echo Platform: Windows
echo.

REM Step 1: Clean
echo Step 1: Cleaning previous builds...
if exist build rmdir /s /q build
if exist dist rmdir /s /q dist

REM Step 2: Install PyInstaller if needed
pip show pyinstaller >nul 2>&1
if errorlevel 1 (
    echo Installing PyInstaller...
    pip install pyinstaller
)

REM Step 3: Build
echo Step 2: Building with PyInstaller...
pyinstaller job-radar.spec --clean

REM Step 4: Copy README
echo Step 3: Adding README...
copy dist\README.txt dist\job-radar\README.txt >nul 2>&1

REM Step 5: Create ZIP
echo Step 4: Creating distribution ZIP...
cd dist
powershell -command "Compress-Archive -Path 'job-radar' -DestinationPath 'job-radar-%VERSION%-windows.zip'"
cd ..

echo.
echo === Build Complete ===
echo Executable: dist\job-radar\job-radar.exe
echo Archive: dist\job-radar-%VERSION%-windows.zip
echo.
echo Quick test: dist\job-radar\job-radar.exe --help
```

4. Create `dist/README.txt` (end-user documentation, committed to repo so build scripts can copy it):

```text
Job Radar v1.1
==============

A job search tool that scores listings against your candidate profile.

GETTING STARTED
---------------

1. Extract this folder to a location on your computer
2. Open a terminal/command prompt in this folder
3. Run the executable:
   - Windows: job-radar.exe --help
   - macOS:   ./job-radar --help  (or open JobRadar.app)
   - Linux:   ./job-radar --help

4. Create your profile:
   - Copy profiles/_template.json to profiles/your_name.json
   - Edit the file with your details (name, skills, target job titles)

5. Run a search:
   - Windows: job-radar.exe --profile profiles/your_name.json
   - macOS:   ./job-radar --profile profiles/your_name.json
   - Linux:   ./job-radar --profile profiles/your_name.json

REQUIREMENTS
------------

- Internet connection (for fetching job listings)
- No Python installation required

TROUBLESHOOTING
---------------

"App is damaged" (macOS):
  Right-click the app > Open (first launch only).
  macOS Gatekeeper blocks unsigned apps by default.

Antivirus warning (Windows):
  Some antivirus software may flag this executable as suspicious.
  This is a false positive common with PyInstaller-packaged apps.
  Add an exception for job-radar.exe in your antivirus settings.

Errors on launch:
  Check ~/job-radar-error.log for detailed error information.

SUPPORT
-------

Report issues at the project's GitHub repository.
```

Actually, `dist/README.txt` should be committed to the repo root as a source file that gets COPIED into dist/ during build. Place it at project root as `README-dist.txt` instead, so it's tracked in git but not confused with the dev README.md. The build scripts will copy it.

Correction: Create the file as `README-dist.txt` in project root. Update build scripts to reference `README-dist.txt` instead of `dist/README.txt`.

5. Install PyInstaller in the project venv: `pip install pyinstaller`

6. Run the build: `./scripts/build.sh`

7. Test the built executable: `./dist/job-radar/job-radar --help`
   Expected: shows help text with all CLI options.

8. Test the built executable startup: `./dist/job-radar/job-radar --version`
   Expected: prints "job-radar 1.1.0"

9. Quick smoke test: `./dist/job-radar/job-radar --profile profiles/_template.json --dry-run`
   Expected: displays banner, shows dry-run query list (may warn about template profile fields).
  </action>
  <verify>
    `ls dist/job-radar/job-radar` confirms executable exists (on macOS/Linux).
    `./dist/job-radar/job-radar --help` displays help text.
    `./dist/job-radar/job-radar --version` prints "job-radar 1.1.0".
    `ls dist/JobRadar.app` confirms macOS .app bundle exists (on macOS only).
    `ls scripts/build.sh scripts/build.bat` confirms both build scripts exist.
    `ls README-dist.txt` confirms end-user README exists.
  </verify>
  <done>
    PyInstaller builds successfully from .spec file.
    dist/job-radar/ contains working executable with all bundled dependencies.
    macOS .app bundle created (on macOS).
    Build scripts exist for all three platforms.
    README-dist.txt contains installation, requirements, and troubleshooting.
    Executable responds to --help and --version correctly.
  </done>
</task>

</tasks>

<verification>
1. `./dist/job-radar/job-radar --help` -- displays CLI help (proves executable launches, deps bundled)
2. `./dist/job-radar/job-radar --version` -- prints "job-radar 1.1.0" (proves version correct)
3. `./dist/job-radar/job-radar --profile profiles/_template.json --dry-run` -- displays banner + dry-run output (proves banner works, search module loads, profile template accessible)
4. `ls dist/job-radar/` -- contains job-radar executable plus supporting files (proves onedir mode)
5. `pyinstaller --version` -- confirms PyInstaller is installed
6. `python -m pytest tests/` -- all tests still pass (backward compatibility)
</verification>

<success_criteria>
- PKG-01/02/03: .spec file configured for Windows, macOS, and Linux (platform-conditional BUNDLE for macOS)
- PKG-04: onedir mode with console=True, startup should be fast
- PKG-05: All dependencies bundled (requests, bs4, platformdirs, pyfiglet, colorama, certifi)
- PKG-06: Profile template accessible in bundle via datas parameter
- PKG-07: Hidden imports explicitly declared (requests, bs4, html.parser, platformdirs, pyfiglet, colorama, certifi, prompt_toolkit, questionary, charset_normalizer, idna, urllib3, soupsieve)
- Executable launches, shows banner, responds to --help and --version
- Build scripts exist for macOS/Linux (.sh) and Windows (.bat)
- README-dist.txt includes usage, requirements, and troubleshooting (antivirus, macOS Gatekeeper)
</success_criteria>

<output>
After completion, create `.planning/phases/06-core-packaging-infrastructure/06-02-SUMMARY.md`
</output>
