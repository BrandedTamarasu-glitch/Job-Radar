---
phase: 29-profile-setup-search-controls
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - job_radar/gui/tag_chip_widget.py
  - job_radar/gui/profile_form.py
autonomous: true

must_haves:
  truths:
    - "User can create a new profile via GUI form fields (name, skills, titles, experience, location, arrangement)"
    - "User can upload a PDF resume via file dialog to pre-fill profile fields"
    - "Profile form validates input on field blur and shows inline error messages"
    - "User can edit an existing profile through the same form pre-filled with current values"
    - "List fields (skills, titles, dealbreakers) display as tag-style chips"
    - "Cancel button shows confirmation dialog if form has unsaved changes"
    - "After saving profile, user is navigated to Search tab with success message"
  artifacts:
    - path: "job_radar/gui/tag_chip_widget.py"
      provides: "Reusable tag-chip input widget for list-type fields"
      exports: ["TagChipWidget"]
    - path: "job_radar/gui/profile_form.py"
      provides: "Profile create/edit form with validation, PDF upload, dirty tracking"
      exports: ["ProfileForm"]
  key_links:
    - from: "job_radar/gui/profile_form.py"
      to: "job_radar/profile_manager.py"
      via: "save_profile() and load_profile() calls"
      pattern: "from job_radar\\.profile_manager import"
    - from: "job_radar/gui/profile_form.py"
      to: "job_radar/pdf_parser.py"
      via: "extract_resume_data() for PDF upload"
      pattern: "from job_radar\\.pdf_parser import"
    - from: "job_radar/gui/profile_form.py"
      to: "job_radar/gui/tag_chip_widget.py"
      via: "TagChipWidget instances for skills, titles, dealbreakers"
      pattern: "from job_radar\\.gui\\.tag_chip_widget import TagChipWidget"
---

<objective>
Create the tag-chip input widget and profile form module as standalone CustomTkinter components ready for integration into main_window.py.

Purpose: Deliver the two core GUI components needed for profile creation, editing, PDF upload, and validation (PROF-01 through PROF-04). These are self-contained modules with no main_window.py modifications — integration happens in Plan 03.

Output: Two new files in job_radar/gui/ — tag_chip_widget.py and profile_form.py — both importable and testable independently.
</objective>

<execution_context>
@/home/corye/.claude/get-shit-done/workflows/execute-plan.md
@/home/corye/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-profile-setup-search-controls/29-CONTEXT.md
@.planning/phases/29-profile-setup-search-controls/29-RESEARCH.md

# Existing code to understand integration surface
@job_radar/gui/main_window.py
@job_radar/profile_manager.py
@job_radar/wizard.py
@job_radar/pdf_parser.py
@job_radar/config.py
@job_radar/paths.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create reusable TagChipWidget for list-type form fields</name>
  <files>job_radar/gui/tag_chip_widget.py</files>
  <action>
Create a CustomTkinter widget class `TagChipWidget(ctk.CTkFrame)` that provides tag-style chip input for list fields (skills, titles, dealbreakers).

**Constructor parameters:**
- `parent` — parent widget
- `placeholder` — placeholder text for the entry field (default: "Type and press Enter")
- Standard CTkFrame kwargs

**Layout:**
- Chips container frame at top using grid or pack layout that wraps chips vertically (not horizontal scroll). Use a CTkFrame inside a scrollable wrapper if needed, or simply stack chips using pack(side="left") with wraplength behavior by re-laying out when chips exceed container width.
- CTkEntry at bottom with the placeholder text.

**Behavior per locked decisions:**
- Type a value, press Enter to add as chip. Strip whitespace, reject empty/duplicate values.
- Each chip is a small CTkFrame containing a CTkLabel (the value text) and a CTkButton with "x" text (remove button). Click X to remove the chip.
- Backspace on empty entry removes the last chip.

**Public API:**
- `get_values() -> list[str]` — returns current chip values
- `set_values(values: list[str])` — clears existing chips and sets new ones (for edit mode pre-fill)
- `clear()` — removes all chips

**Implementation details:**
- Store chips as list of dicts: `[{"value": str, "frame": CTkFrame}]` for easy removal
- Chip styling: small rounded frame, value label + "x" button packed side-by-side
- Use `fg_color` on chip frames to distinguish them visually from the background
- Bind `<Return>` on entry for adding, `<BackSpace>` for removing last (only when entry is empty)
- Validate: strip whitespace, skip empty strings, skip duplicates (case-insensitive comparison)

Follow codebase conventions: module docstring, type hints, private underscore-prefixed methods.
  </action>
  <verify>
Run: `python -c "from job_radar.gui.tag_chip_widget import TagChipWidget; print('TagChipWidget imported successfully')"`
Verify the class has get_values, set_values, and clear methods:
`python -c "import inspect; from job_radar.gui.tag_chip_widget import TagChipWidget; methods = [m for m in dir(TagChipWidget) if not m.startswith('_')]; assert 'get_values' in methods and 'set_values' in methods and 'clear' in methods; print('API verified:', methods)"`
  </verify>
  <done>
TagChipWidget imports without error, exposes get_values/set_values/clear public API, handles Enter-to-add, X-to-remove, and Backspace-on-empty-to-remove-last chip behaviors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ProfileForm widget with validation, PDF upload, and dirty tracking</name>
  <files>job_radar/gui/profile_form.py</files>
  <action>
Create a CustomTkinter widget class `ProfileForm(ctk.CTkFrame)` that provides the complete profile creation/editing form.

**Constructor parameters:**
- `parent` — parent widget
- `on_save_callback` — callable(profile_data: dict) invoked when user saves successfully
- `on_cancel_callback` — callable() invoked when user cancels
- `existing_profile` — optional dict for edit mode pre-fill (None = create mode)
- Standard CTkFrame kwargs

**Form layout per locked decisions:**
- One scrollable page using CTkScrollableFrame
- Fields organized in grouped sections with header labels:
  - "Identity" section: Name (CTkEntry), Years of Experience (CTkEntry)
  - "Skills & Titles" section: Target Titles (TagChipWidget), Core Skills (TagChipWidget), Secondary Skills (TagChipWidget, optional)
  - "Preferences" section: Location (CTkEntry, optional), Work Arrangement (CTkOptionMenu or TagChipWidget with options like remote/hybrid/onsite), Domain Expertise (TagChipWidget, optional), Compensation Floor (CTkEntry, optional)
  - "Filters" section: Dealbreakers (TagChipWidget, optional)

**Resume PDF upload per locked decisions:**
- Before showing the form, display a choice view: "Upload resume or fill manually?"
- Two buttons: "Upload Resume PDF" and "Fill Manually"
- "Upload Resume PDF" opens tkinter.filedialog.askopenfilename with PDF filter
- On successful parse via pdf_parser.extract_resume_data(), show brief success message then pre-fill form fields
- On parse error, show error message and offer to continue with manual entry
- "Fill Manually" skips directly to form
- If existing_profile is provided (edit mode), skip this choice entirely and go straight to form

**Validation per locked decisions:**
- Validation fires on field blur (FocusOut event) for each entry widget
- Reuse validation logic from wizard.py — extract the core validation logic into standalone functions:
  - Name: non-empty (from NonEmptyValidator pattern)
  - Years experience: integer 0-50 (from YearsExperienceValidator pattern)
  - Compensation: optional, but if provided must be valid number 0-1,000,000 (from CompensationValidator pattern)
  - Skills/titles: validated via TagChipWidget (at least 1 item required for core_skills and target_titles)
- Each field has an error label below it that shows/hides red error text
- On Save click: validate ALL fields programmatically (iterate each validator), focus first invalid field if any fail
- Do NOT import questionary validators directly (they depend on questionary.Validator base class). Instead, write thin wrapper functions that extract the same validation logic: `validate_name(text) -> tuple[bool, str]`, `validate_years(text) -> tuple[bool, str]`, `validate_compensation(text) -> tuple[bool, str]`

**Save behavior per locked decisions:**
- Build profile dict from form values (same structure as wizard.py output)
- Derive level from years_experience (junior/mid/senior/principal using same thresholds as wizard.py)
- Call profile_manager.save_profile(profile_data, profile_path) for atomic write with backup
- On success: invoke on_save_callback with the saved profile data
- On ProfileValidationError: show error in the form (not a dialog)

**Edit mode:**
- When existing_profile is provided, pre-fill all fields using set methods
- Store original values snapshot on load for dirty tracking

**Dirty tracking per locked decisions:**
- Track original form values (snapshot at form load time)
- Compare current values to original on cancel
- If dirty (values differ): show confirmation dialog "Discard changes?"
- If clean: cancel immediately without dialog

**Cancel button:**
- Always visible at bottom of form alongside Save button
- Calls _check_dirty() which either cancels immediately or shows confirmation

Follow codebase conventions: module docstring, type hints, private methods with underscore prefix. Use relative imports for job_radar modules.
  </action>
  <verify>
Run: `python -c "from job_radar.gui.profile_form import ProfileForm; print('ProfileForm imported successfully')"`
Verify the module compiles without syntax errors:
`python -m py_compile job_radar/gui/profile_form.py && echo 'Syntax OK'`
Grep to confirm key integrations exist:
- `grep -c "from job_radar.profile_manager import" job_radar/gui/profile_form.py` should be >= 1
- `grep -c "from job_radar.gui.tag_chip_widget import" job_radar/gui/profile_form.py` should be >= 1
- `grep -c "FocusOut" job_radar/gui/profile_form.py` should be >= 1
- `grep -c "filedialog" job_radar/gui/profile_form.py` should be >= 1
  </verify>
  <done>
ProfileForm imports cleanly, includes: grouped sections with headers, TagChipWidget for list fields, FocusOut blur validation, PDF upload via filedialog with extract_resume_data(), dirty tracking with cancel confirmation, Save that calls profile_manager.save_profile(), and edit mode pre-fill from existing profile dict.
  </done>
</task>

</tasks>

<verification>
1. Both new files import without errors: `python -c "from job_radar.gui.tag_chip_widget import TagChipWidget; from job_radar.gui.profile_form import ProfileForm; print('All imports OK')"`
2. No circular import issues (both modules import from existing job_radar modules, not from each other except tag_chip -> profile_form)
3. py_compile passes for both files
4. grep confirms integration with profile_manager, pdf_parser, tag_chip_widget, and FocusOut validation
</verification>

<success_criteria>
- TagChipWidget is a self-contained CustomTkinter widget with Enter-to-add, X-to-remove, Backspace-to-remove-last API
- ProfileForm provides complete profile create/edit form with grouped sections, inline validation, PDF upload, dirty tracking, and save via profile_manager
- Both modules follow codebase conventions and compile without errors
- No modifications to existing files (integration happens in Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/29-profile-setup-search-controls/29-01-SUMMARY.md`
</output>
